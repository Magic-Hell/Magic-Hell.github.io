<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>springboot学习</title>
      <link href="/2023/08/21/springboot%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/21/springboot%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="1-Spring-Boot概述"><a href="#1-Spring-Boot概述" class="headerlink" title="1. Spring Boot概述"></a>1. Spring Boot概述</h1><h2 id="1-Spring-Boot-概念"><a href="#1-Spring-Boot-概念" class="headerlink" title="1. Spring Boot 概念"></a>1. Spring Boot 概念</h2><p>SpringBoot提供了一种快速使用Spring的方式，基于约定优于配置的思想，可以让开发人员不必在配置与逻辑业务之间进行思维的功换，全身心的投入到逻辑业务的代码编写中，从而大大提高了开发的效率，一定程度上缩短了项目周期。2014年4月，Spring Boot 1.0.0发布Spring的顶级项目之-(<a href="https://spring.io)./">https://spring.io)。</a></p><h2 id="2-环境要求"><a href="#2-环境要求" class="headerlink" title="2. 环境要求"></a>2. 环境要求</h2><table><thead><tr><th>环境&amp;工具</th><th>版本（or later）</th></tr></thead><tbody><tr><td>SpringBoot</td><td>3.0.5+</td></tr><tr><td>IDEA</td><td>2021.2.1+</td></tr><tr><td>Java</td><td>17+</td></tr><tr><td>Maven</td><td>3.5+</td></tr><tr><td>Tomcat</td><td>10.0+</td></tr><tr><td>Servlet</td><td>5.0+</td></tr><tr><td>GraalVM Community</td><td>22.3+</td></tr><tr><td>Native Build Tools</td><td>0.9.19+</td></tr></tbody></table><h2 id="3-SpringBoot是什么"><a href="#3-SpringBoot是什么" class="headerlink" title="3. SpringBoot是什么"></a>3. SpringBoot是什么</h2><p>SpringBoot 帮我们简单、快速地创建一个独立的、生产级别的 <strong>Spring 应用（说明：SpringBoot底层是Spring）</strong></p><p>大多数 SpringBoot 应用只需要编写少量配置即可快速整合 Spring 平台以及第三方技术</p><p><strong>特性：</strong></p><ul><li><p>快速创建独立 Spring 应用</p></li><li><ul><li>SSM：导包、写配置、启动运行</li></ul></li><li><p>直接嵌入Tomcat、Jetty or Undertow（无需部署 war 包）【Servlet容器】</p></li><li><ul><li>linux  java tomcat mysql： war 放到 tomcat 的 webapps下</li><li>jar： java环境；  java -jar</li></ul></li><li><p><strong>重点</strong>：提供可选的starter，简化应用<strong>整合</strong></p></li><li><ul><li><strong>场景启动器</strong>（starter）：web、json、邮件、oss（对象存储）、异步、定时任务、缓存…</li><li>导包一堆，控制好版本。</li><li>为每一种场景准备了一个依赖； <strong>web-starter。mybatis-starter</strong></li></ul></li><li><p><strong>重点：</strong>按需自动配置 Spring 以及 第三方库</p></li><li><ul><li>如果这些场景我要使用（生效）。这个场景的所有配置都会自动配置好。</li><li><strong>约定大于配置</strong>：每个场景都有很多默认配置。</li><li>自定义：配置文件中修改几项就可以</li></ul></li><li><p>提供生产级特性：如 监控指标、健康检查、外部化配置等</p></li><li><ul><li>监控指标、健康检查（k8s）、外部化配置</li></ul></li><li><p>无代码生成、无xml</p><p>总结 ： 简化开发，简化配置，简化整合，简化部署，简化监控，简化运维。</p></li></ul><h1 id="2-快速体验"><a href="#2-快速体验" class="headerlink" title="2. 快速体验"></a>2. 快速体验</h1><p>需求： 浏览器发送**&#x2F;hello**请求，返回”<strong>Hello,Spring Boot 3!</strong>“</p><h2 id="1-开发流程"><a href="#1-开发流程" class="headerlink" title="1. 开发流程"></a>1. 开发流程</h2><h3 id="1-创建项目"><a href="#1-创建项目" class="headerlink" title="1. 创建项目"></a>1. 创建项目</h3><p>maven项目</p><pre><code class="xml">&lt;!--    所有springboot项目都必须继承自 spring-boot-starter-parent --&gt;    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;3.0.5&lt;/version&gt;    &lt;/parent&gt;</code></pre><h3 id="2-导入场景"><a href="#2-导入场景" class="headerlink" title="2. 导入场景"></a>2. 导入场景</h3><p>场景启动器</p><pre><code class="xml">    &lt;dependencies&gt;&lt;!--        web开发的场景启动器 --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;        &lt;/dependency&gt;    &lt;/dependencies&gt;</code></pre><h3 id="3-主程序"><a href="#3-主程序" class="headerlink" title="3. 主程序"></a>3. 主程序</h3><pre><code class="Java">@SpringBootApplication //这是一个SpringBoot应用public class MainApplication &#123;    public static void main(String[] args) &#123;        SpringApplication.run(MainApplication.class,args);    &#125;&#125;</code></pre><h3 id="4-业务层"><a href="#4-业务层" class="headerlink" title="4. 业务层"></a>4. 业务层</h3><pre><code class="Java">@RestControllerpublic class HelloController &#123;    @GetMapping(&quot;/hello&quot;)    public String hello()&#123;        return &quot;Hello,Spring Boot 3!&quot;;    &#125;&#125;</code></pre><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5. 测试"></a>5. 测试</h3><p>默认启动访问： localhost:8080</p><h3 id="6-打包"><a href="#6-打包" class="headerlink" title="6. 打包"></a>6. 打包</h3><pre><code class="xml">&lt;!--    SpringBoot应用打包插件--&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;            &lt;/plugin&gt;        &lt;/plugins&gt;    &lt;/build&gt;</code></pre><p><code>mvn clean package</code>把项目打成可执行的jar包</p><p><code>java -jar demo.jar</code>启动项目</p><h3 id="3-特性小结"><a href="#3-特性小结" class="headerlink" title="3. 特性小结"></a>3. 特性小结</h3><h4 id="1-简化整合"><a href="#1-简化整合" class="headerlink" title="1. 简化整合"></a>1. 简化整合</h4><p>导入相关的场景，拥有相关的功能。场景启动器</p><p>默认支持的所有场景：<a href="https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters">https://docs.spring.io/spring-boot/docs/current/reference/html/using.html#using.build-systems.starters</a></p><ul><li>官方提供的场景：命名为：<code>spring-boot-starter-*</code></li><li>第三方提供场景：命名为：<code>*-spring-boot-starter</code></li></ul><p><strong>场景一导入，万物皆就绪。</strong></p><h4 id="2-简化开发"><a href="#2-简化开发" class="headerlink" title="2. 简化开发"></a>2. 简化开发</h4><p>无需编写任何配置，直接开发业务</p><h4 id="3-简化配置"><a href="#3-简化配置" class="headerlink" title="3. 简化配置"></a>3. 简化配置</h4><p><code>application.properties</code>：</p><ul><li><p>集中式管理配置。只需要修改这个文件就行 。</p></li><li><p>配置基本都有默认值</p></li><li><p>能写的所有配置都在： <a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties">https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties</a></p></li></ul><h4 id="4-简化部署"><a href="#4-简化部署" class="headerlink" title="4. 简化部署"></a>4. 简化部署</h4><p>打包为可执行的jar包。</p><p>linux服务器上有java环境。</p><h1 id="3-Spring-Initializr-创建向导"><a href="#3-Spring-Initializr-创建向导" class="headerlink" title="3. Spring Initializr 创建向导"></a>3. Spring Initializr 创建向导</h1><p>一键创建好整个项目结构</p><p>![批注 2023-08-21 231801](springboot学习&#x2F;批注 2023-08-21 231801.png)</p><h1 id="4-应用分析"><a href="#4-应用分析" class="headerlink" title="4. 应用分析"></a>4. 应用分析</h1><h2 id="1-依赖管理机制"><a href="#1-依赖管理机制" class="headerlink" title="1. 依赖管理机制"></a>1. 依赖管理机制</h2><p>思考：</p><p>1、为什么导入<code>starter-web</code>所有相关依赖都导入进来？</p><ul><li>开发什么场景，导入什么<strong>场景启动器。</strong></li><li><strong>maven依赖传递原则。A-B-C： A就拥有B和C</strong></li><li>导入 场景启动器。 场景启动器 自动把这个场景的所有核心依赖全部导入进来</li></ul><p>2、为什么版本号都不用写？</p><ul><li>每个boot项目都有一个父项目<code>spring-boot-starter-parent</code></li><li>parent的父项目是<code>spring-boot-dependencies</code></li><li>父项目 <strong>版本仲裁中心</strong>，把所有常见的jar的依赖版本都声明好了。</li><li>比如：<code>mysql-connector-j</code></li></ul><p>3、自定义版本号</p><ul><li><p>利用maven的就近原则</p></li><li><ul><li><p>直接在当前项目<code>properties</code>标签中声明父项目用的版本属性的key</p></li><li><p>直接在<strong>导入依赖的时候声明版本</strong></p></li></ul></li></ul><h2 id="2-自动配置机制"><a href="#2-自动配置机制" class="headerlink" title="2.自动配置机制"></a>2.自动配置机制</h2><h3 id="1-初步了解"><a href="#1-初步了解" class="headerlink" title="1. 初步了解"></a>1. 初步了解</h3><ul><li><strong>自动配置</strong>的 Tomcat、SpringMVC 等</li><li><ul><li><strong>导入场景</strong>，容器中就会自动配置好这个场景的核心组件。</li><li>以前：DispatcherServlet、ViewResolver、CharacterEncodingFilter….</li><li>现在：自动配置好的这些组件</li><li>验证：<strong>容器中有了什么组件，就具有什么功能</strong></li></ul></li></ul><pre><code class="Java">    public static void main(String[] args) &#123;        //java10： 局部变量类型的自动推断        var ioc = SpringApplication.run(MainApplication.class, args);        //1、获取容器中所有组件的名字        String[] names = ioc.getBeanDefinitionNames();        //2、挨个遍历：        // dispatcherServlet、beanNameViewResolver、characterEncodingFilter、multipartResolver        // SpringBoot把以前配置的核心组件现在都给我们自动配置好了。        for (String name : names) &#123;            System.out.println(name);        &#125;    &#125;</code></pre><p>![批注 2023-08-22 001029](springboot学习&#x2F;批注 2023-08-22 001029.png)</p>]]></content>
      
      
      <categories>
          
          <category> Spring </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>UML学习</title>
      <link href="/2023/08/19/UML%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/19/UML%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一章选择题"><a href="#第一章选择题" class="headerlink" title="第一章选择题"></a>第一章选择题</h1><ol><li><p>(单选题)什么不是面向对象程序设计的主要特征。（D）<br>A. 封装<br>B. 多态<br>C. 继承<br>D. 结构</p></li><li><p>(单选题)封装是一种（D）技术。<br>A. 组装<br>B. 产品化<br>C. 固化<br>D. 信息隐藏</p></li><li><p>(单选题)封装的目的是使对象的（A）分离。<br>A. 定义和实现<br>B. 设计和测试<br>C. 设计和实现<br>D. 分析和定义</p></li><li><p>(单选题)下列选项中不属于面向对象方法的优势之一的是（C）<br>A. 复用性强<br>B. 改善了软件结构<br>C. 软件的执行效率更高<br>D. 抽象更符合人类的思维习惯</p></li><li><p>(单选题)（A）是面向对象方法中用来描述“对客户隐藏对象属性和实现细节”的概念。<br>A. 封装<br>B. 继承<br>C. 多态<br>D. 抽象</p></li><li><p>(单选题)软件工程的概念是在（B）年被首次提出的。<br>A. 1949<br>B. 1968<br>C. 1972<br>D. 1989</p></li><li><p>(单选题)下列不属于软件工程的目标的一项是（C）<br>A. 提高软件产品的质量<br>B. 提高软件产品的可靠性<br>C. 减少软件产品的需求<br>D. 控制软件产品的开发成本</p></li><li><p>(单选题)软件危机产生的主要原因是（D）<br>A. 软件工具落后<br>B. 软件生产能力不足<br>C. 对软件认识不够<br>D. 软件本身的特点与开发方法</p></li></ol><h1 id="第二章选择题"><a href="#第二章选择题" class="headerlink" title="第二章选择题"></a>第二章选择题</h1><ol><li><p>(单选题)UML的全称是（B）<br>A. Unify Modeling Language<br>B. Unified Modeling Language<br>C. Unified Modem Language<br>D. Unified Making Language</p></li><li><p>(单选题)OMT方法是由下面哪位科学家提出的？（B）<br>A. Booch<br>B. Rumbaugh<br>C. Coad<br>D. Jacobson</p></li><li><p>(单选题)什么概念被认为是第二代面向对象技术的标志？（A）<br>A. 用例<br>B. UML语言<br>C. 活动图<br>D. 组件图</p></li><li><p>(单选题)正式的UML2.0规范是在（C）年通过的。<br>A. 2001<br>B. 2003<br>C. 2005<br>D. 2007</p></li><li><p>(单选题)下列表述中不属于UML的目标的是（C）<br>A. 为建模者提供可用的、富有表达力的、可视化的建模语言<br>B. 支持独立于编程语言和开发过程的规范<br>C. 称为一门独立的编程语言<br>D. 推动面向对象建模工具市场的成长</p></li><li><p>(单选题)UML主要用于（D）<br>A. 基于螺旋模型的结构化开发方法<br>B. 基于需求动态定义的原型化方法<br>C. 基于数据的数据流开发方法<br>D. 基于对象的面向对象的方法</p></li><li><p>(单选题)下面面向对象方法中不是UML所融合的方法的一项是（D）<br>A. Booch<br>B. OOSE<br>C. OMT<br>D. Coad&#x2F;Yourdon</p></li><li><p>(单选题)下列关于模型的表述，不正确的一项是（A）<br>A. 建模语言只能用图形表示<br>B. 模型所描绘的系统蓝图既可以包括详细的计划，也可以包括系统的总体规划<br>C. 模型可以帮助开发组生成有用的工作产品<br>D. 最好的模型总是与现实世界联系密切</p></li></ol><h1 id="第三章选择题"><a href="#第三章选择题" class="headerlink" title="第三章选择题"></a>第三章选择题</h1><ol><li><p>(单选题)类图应该画在Rose的哪种视图中？（B）<br>A. Use Case View<br>B. Logic View<br>C. Component View<br>D. Deployment View</p></li><li><p>(单选题)下面哪个不是UML中的静态视图？（A）<br>A. 状态图<br>B. 用例图<br>C. 对象图<br>D. 类图</p></li><li><p>(单选题)在UML中，（B）图显示了一组类、接口、协作以及他们之间的关系。<br>A. 状态图<br>B. 类图<br>C. 用例图<br>D. 部署图</p></li><li><p>(单选题)UML中有四种关系是：依赖、泛化、关联和（C）<br>A. 继承<br>B. 合作<br>C. 实现<br>D. 抽象</p></li><li><p>(单选题)UML中的事物包括：结构事物、分组事物、注释事物和（D）<br>A. 实体事物<br>B. 边界事物<br>C. 控制事物<br>D. 动作事物</p></li><li><p>(单选题)UML体系包括三个部分：UML基本构造块，（A）和UML公共机制<br>A. UML规则<br>B. UML命名<br>C. UML模型<br>D. UML约束</p></li><li><p>(单选题)下列描述中，哪个不是建模的基本原则。（D）<br>A. 要仔细的选择模型<br>B. 每一种模型可以在不同的精度级别上表示所要开发的系统<br>C. 模型要与现实相联系<br>D. 对一个重要的系统用一个模型就可以充分描述</p></li><li><p>(单选题)在 ROSE中，时序图和协作图（或通信图）通常建立在  (  B ) 下的Use Case Realization包中。<br>A. Use Case View<br>B. Logical View<br>C. Component View<br>D. Deployment View</p></li><li><p>(单选题)下面哪个视图属于UML语言的交互图？（D）<br>A. 行为图<br>B. 状态图<br>C. 实现图<br>D. 顺序图</p></li><li><p>(单选题)领域模型又称为（C）<br>A. 业务流程模型<br>B. 用例模型<br>C. 概念模型<br>D. 设计模型</p></li><li><p>(单选题)UML图不包括（D）<br>A. 用例图<br>B. 类图<br>C. 状态图<br>D. 流程图</p></li><li><p>(单选题)当需要表示某个元素的特性信息时，可以使用（D）这种扩展机制。<br>A. 约束<br>B. 构造型<br>C. 注释<br>D. 标记值</p></li><li><p>(单选题)在“4+1”架构中，（B）主要用来描述软件的各个模块的组织方式。<br>A. 逻辑视图<br>B. 开发视图<br>C. 进程视图<br>D. 物理视图</p></li><li><p>(单选题)UML使用（D）来描述接口和实现接口的类之间的关系。<br>A. 关联关系<br>B. 泛化关系<br>C. 依赖关系<br>D. 实现关系</p></li><li><p>(单选题)下列UML图中不属于结构图的一项是（D）。<br>A. 类图<br>B. 对象图<br>C. 组件图<br>D. 顺序图</p></li><li><p>(单选题)下列UML图中不是UML 2.0规范新增加的图的一项是（A）。<br>A. 类图<br>B. 交互概览图<br>C. 组合结构图<br>D. 时序图</p></li><li><p>(单选题)下列选项中不属于UML的扩展机制的是（C）。<br>A. 约束<br>B. 构造型<br>C. 注释<br>D. 标记值</p></li><li><p>(单选题)描述了一组动作序列的模型元素是（C）。<br>A. 类<br>B. 接口<br>C. 用例<br>D. 组件</p></li><li><p>(单选题)在UML中表示一般事物与特殊事物之间的关系是（B）。<br>A. 关联关系<br>B. 泛化关系<br>C. 依赖关系<br>D. 实现关系</p></li><li><p>(单选题)我们可以使用UML中的（A）来描述图书馆与书的关系。<br>A. 关联关系<br>B. 泛化关系<br>C. 依赖关系<br>D. 实现关系</p></li></ol><h1 id="第四章选择题"><a href="#第四章选择题" class="headerlink" title="第四章选择题"></a>第四章选择题</h1><ol><li><p>(单选题)用例（Use-case）用来描述系统在事件做出响应时所采取的行动。用例之间是具有相关性的。在一个“订单输入子系统”中，创建新订单和更新订单都需要检查用户帐号是否正确。那么，用例“创建新订单”、“更新订单”与用例“检查用户帐号”之间是（　A　）关系<br>A. 包含（include）<br>B. 扩展（extend）<br>C. 分类（classification）<br>D. 聚集（aggregation）</p></li><li><p>(单选题)UML中，对象行为是通过交互来实现的，是对象间为完成某一目的而进行的一系列消息交换。消息序列可用两种类来表示，分别是（　D　）<br>A. 状态图和顺序图<br>B. 活动图和协作图<br>C. 状态图和活动图<br>D. 顺序图和协作图</p></li><li><p>(单选题)UML中，用例图展示了外部Actor与系统所提供的用例之间的连接，UML中的外部Actor是指（　　D　）<br>A. 人员<br>B. 单位<br>C. 人员和单位<br>D. 人员和外部系统</p></li><li><p>(单选题)<br>下图中的空心箭头连线表示（ A   ）关系。<br><img src="https://img-blog.csdnimg.cn/7008f74b68c94fce9f30ffc49817844e.png" alt="在这里插入图片描述"><br>A. 泛化<br>B. 包含<br>C. 扩展<br>D. 实现</p></li><li><p>(单选题)在用例之间，会有三种不同的关系，下列不是用例之间关系的是（    D   ）。<br>A. 包含（include）<br>B. 扩展（extend）<br>C. 泛化（generalization）<br>D. 关联（connect ）</p></li><li><p>(单选题)在ATM自动取款机的工作模型中（用户通过输入正确的用户资料，从银行取钱的过程），下面不是“Actor”的是（    D  ）。<br>A. 用户<br>B. ATM提款机<br>C. ATM提款机管理员<br>D. 取款</p></li><li><p>(单选题)下面不属于用例之间关系的是（A）<br>A. 友元<br>B. 扩展<br>C. 包含<br>D. 泛化</p></li><li><p>(单选题)在建立系统的用例模型时，首先应该确定系统的参与者。以下问题中，对于确定参与者没有用处的是 (  C ) 。<br>A. 谁是系统的主要用户，即谁使用系统的主要功能<br>B. 谁来管理、维护系统，以保证系统的正常运行<br>C. 系统的功能应如何实现<br>D. 系统需要和哪些其他的系统交互</p></li><li><p>(单选题)执行者（Actor）与用例之间的关系是（C）<br>A. 包含关系<br>B. 泛化关系<br>C. 关联关系<br>D. 扩展关系</p></li><li><p>(单选题)包含关系是在（C）关系的基础上通过添加构造型实现的。<br>A. 关联关系<br>B. 泛化关系<br>C. 依赖关系<br>D. 实现关系</p></li><li><p>(单选题)下面不属于用例图的作用的是（B）。<br>A. 展示软件的功能<br>B. 展示软件的特性<br>C. 展示软件使用者与软件功能的关系<br>D. 展示软件功能之间的关系</p></li><li><p>(单选题)下列不属于构成用例图的要素是（A）<br>A. 包含<br>B. 参与者<br>C. 用例<br>D. 关系</p></li><li><p>(单选题)对于ATM系统的“取款”用例（客户通过插入银行卡并输入正确的密码从ATM机中成功取款的过程），（C）应该作为该用例的参与者。<br>A. ATM机<br>B. 银行工作人员<br>C. 取款客户<br>D. 取款</p></li><li><p>(单选题)下列关于用例图的描述，错误的是（D）<br>A. 用例图表示系统的行为<br>B. 用例在用例图中使用椭圆表示<br>C. 参与者在用例图中使用小人表示<br>D. 一般使用从用例指向参与者的箭头表示启动关系</p></li><li><p>(单选题)在进行某网上商店的用例图绘制时，（A）是一个不合适的用例。<br>A. 打开页面<br>B. 购买商品<br>C. 管理订单<br>D. 搜索商品</p></li><li><p>(单选题)下列说法中，不正确的是（B）<br>A. 用例和参与者之间的对应关系是关联关系，它表示参与者使用了系统的用例<br>B. 参与者指的是人，不能是子系统和时间等概念<br>C. 特殊需求指的是一个用例的非功能需求和设计约束<br>D. 在扩展关系中，基础用例提供了一个或多个插入点，扩展用例在这些插入点中提供了另外的行为</p></li><li><p>(单选题)以下各项中，（B）不是用例图适于表达的内容。<br>A. 参与者<br>B. 事件流<br>C. 用例关系<br>D. 系统边界</p></li></ol><h1 id="第五章选择题"><a href="#第五章选择题" class="headerlink" title="第五章选择题"></a>第五章选择题</h1><ol><li><p>(单选题)下列关于类方法的声明，不正确的是（C）<br>A. 方法定义了类所许可的行动<br>B. 从一个类所创建的所有对象可以使用同一组属性和方法<br>C. 每个方法应该有一个参数<br>D. 如果在同一个类中定义了类似的操作，则他们的行为应该是类似的</p></li><li><p>(单选题)类通常可以分为实体类，（  C   ）和边界类。<br>A. 父类<br>B. 子类<br>C. 控制类<br>D. 祖先类</p></li><li><p>(单选题)通常对象有很多属性，下面仅能在对象内部访问的属性可见性限制是（D）<br>A. public<br>B. protected<br>C. friendly<br>D. private</p></li><li><p>(单选题)类的结构是（D）。<br>A. 由代码来表示<br>B. 由属性和关系来表示<br>C. 由操作来表示<br>D. B&amp;C</p></li><li><p>(单选题)类的行为是（A）<br>A. 由一组操作决定<br>B. 由类的属性决定<br>C. 对类的每一个对象唯一的<br>D. 由父类决定</p></li><li><p>(单选题)在类图中，下面哪个符号表示继承关系（C）</p></li></ol><p>A. <img src="https://img-blog.csdnimg.cn/5b6c8d06d7c2436080547cba4a76c148.png" alt="在这里插入图片描述"><br>B. <img src="https://img-blog.csdnimg.cn/f08db98d84254ccd947348f5be9a7471.png" alt="在这里插入图片描述"></p><p>C. <img src="https://img-blog.csdnimg.cn/d2e25cbf35214adfbcc8279c3b33d1d2.png" alt="在这里插入图片描述"></p><p>D. <img src="https://img-blog.csdnimg.cn/d1e6a9e8a4374015be87e942d76de503.png" alt="在这里插入图片描述"></p><ol start="7"><li><p>(单选题)下面的(A)模式将对象组合成树形结构以表示“部分-整体”的层次结构，并使得用户对单个对象和组合对象的使用具有一致性。<br>A. 组合（Composite）<br>B. 桥接（Bridge）<br>C. 修饰（Decorator）<br>D. 外观（Facade）</p></li><li><p>(单选题)如下的短语(B)能最好地表示“泛化”关系。<br>A. is a part of<br>B. is a kind of<br>C. is a replica of<br>D. is an inheritance of</p></li><li><p>(单选题)类A的一个操作调用类B的一个操作，且这两个类之间不存在其他关系，那么类A和类B之间是  (  C   )  关系。<br>A. 实现<br>B. 继承<br>C. 依赖<br>D. 关联</p></li><li><p>(单选题)在用ROSE创建的类图中，“#”表示的可见性是(B)<br>A. public<br>B. protected<br>C. private<br>D. package</p></li><li><p>(单选题)UML中关联的多重度是指(B)<br>A. 一个类有多个方法被另一个类调用<br>B. 一个类的实体类能够与另一个类的多个实体类相关联<br>C. 一个类的某个方法被另一个类调用的次数<br>D. 两个类所具有的相同的方法和属性</p></li><li><p>(单选题)类之间的关系不包括（D）<br>A. 依赖关系<br>B. 泛化关系<br>C. 实现关系<br>D. 分解关系</p></li><li><p>(单选题)类图应该画在ROSE的哪种（  B ）视图中。<br>A. Use Case View<br>B. Logic View<br>C. Component View<br>D. Department View</p></li><li><p>(单选题)汽车（Car）由轮子、发动机、油箱、座椅、方向盘等组成，那么Car类和其他类（Wheel、Engin、Tank、Chair、SteeringWheel）之间的关系是（A）。<br>A. 关联关系<br>B. 泛化关系<br>C. 实现关系<br>D. 依赖关系</p></li><li><p>(单选题)假设类A的一个操作的其中一个参数是类B的一个对象，且这两个类之间不存在其他关系，那么类A和类B之间构成（D）。<br>A. 关联关系<br>B. 泛化关系<br>C. 实现关系<br>D. 依赖关系</p></li><li><p>(单选题)在下列选项中不属于类图的元素的是（B）<br>A. 类<br>B. 用例<br>C. 接口<br>D. 关联类</p></li><li><p>(单选题)当类的属性与操作添加了（B）限定符后表示该属性或操作只对本类可见，不能被其他类访问。<br>A. public<br>B. private<br>C. protected<br>D. package</p></li><li><p>(单选题)下列关于接口关系的说法不正确的是（D）。<br>A. 接口是一种特殊的类<br>B. 接口可以看成是有interface构造型的类<br>C. 一个类可以通过实现接口从而具有接口指定的行为<br>D. 在调用设计合理的接口时，需要知道类对接口实现的具体信息</p></li><li><p>(单选题)下列对类和接口的描述不正确的是（D）。<br>A. 当使用子类去替换一处父类时，设计良好的软件应当可以正确实现功能<br>B. 接口的方法名必须是公开（public）的<br>C. 一个类可以实现多个接口<br>D. 当一个类拥有另外一个类的全部属性和方法的时候，他们之间是实现关系</p></li><li><p>(单选题)下列关于类图的说法中正确的是（C）<br>A. 类图是由类、组件、包等模型元素以及它们间的关系构成的<br>B. 类图的目的在于描述系统的运行方式，而不是系统如何构成<br>C. 类图通过系统中的类与类间的关系描述了系统的静态特性<br>D. 类图和数据模型有许多相似之处，区别是数据模型不仅描述了内部信息的结构，也包含了系统的内部行为</p></li></ol><h1 id="第六章选择题"><a href="#第六章选择题" class="headerlink" title="第六章选择题"></a>第六章选择题</h1><ol><li><p>(单选题)下列关于链的叙述中，正确的一项是（D）。<br>A. 链就是关联关系<br>B. 链使用一根虚线段来表示<br>C. 链用来表示对象和类之间的关系<br>D. 链没有多重性</p></li><li><p>(单选题)下列关于对象图的叙述中，错误的一项是（C）。<br>A. 对象图显示了某时刻的一组对象以及他们之间的关系<br>B. 对象图中的主要元素是链和对象<br>C. 对象图中的链是泛化关系的实例<br>D. 对象图主要用于说明系统在某一特定时刻的具体运行状态</p></li><li><p>(单选题)下列关于类和对象的关系的叙述中，错误的一项是（B）。<br>A. 每个对象都是某个类的实例<br>B. 每个类某一时刻必定存在对象实体<br>C. 类是静态的描述<br>D. 类之间可能存在关联关系，对象之间也可能存在链</p></li><li><p>(单选题)下列关于对象图的叙述中，错误的一项是（C）。<br>A. 对象图显示了某一时刻的一组对象以及他们之间的关系<br>B. 对象图可以被看作是类图的实例<br>C. 对象图表达的交互的动态部分<br>D. 对象图中的建模元素主要有对象和链</p></li></ol><h1 id="第七章选择题"><a href="#第七章选择题" class="headerlink" title="第七章选择题"></a>第七章选择题</h1><ol><li><p>(单选题)（ A  ）是用于把元素组织成组的通用机制<br>A. 包<br>B. 类<br>C. 接口<br>D. 组件</p></li><li><p>(单选题)关于包的描述，哪个不正确（   D　 ）<br>A. 和其他建模元素一样，每个包必须有一个区别于其他包的名字<br>B. 包中可以包含其他元素，比如类、接口、组件等<br>C. 包的可见性包括：公有、私有、受保护<br>D. 导出（export）使得一个包中的元素可以单项访问另一个包中的元素</p></li><li><p>(单选题)在下列选项中，包元素之间可能形成的关系是（B）。<br>A. 关联关系<br>B. 依赖关系<br>C. 实现关系<br>D. 扩展关系</p></li><li><p>(单选题)包图的组成不包括（D）。<br>A. 包的名称和构造型<br>B. 包中含有的元素<br>C. 包与包之间的关系<br>D. 包间的消息和发送者</p></li><li><p>(单选题)下列关于包的用途，说法不正确的是（C）。<br>A. 描述需求和设计的高层情况<br>B. 组织源代码<br>C. 细化用例表达<br>D. 将复杂系统在逻辑层面上模块化</p></li><li><p>(单选题)下列选项中，不能直接放在包中的元素是（B）。<br>A. 类<br>B. 操作<br>C. 包<br>D. 对象图</p></li></ol><h1 id="第八章选择题"><a href="#第八章选择题" class="headerlink" title="第八章选择题"></a>第八章选择题</h1><ol><li><p>(单选题)顺序图由类角色，生命线，激活期和（  B ）组成<br>A. 关系<br>B. 消息<br>C. 用例<br>D. 实体</p></li><li><p>(单选题)一个对象和另一个对象之间，通过消息来进行通信。消息通信在面向对象的语言中即（ C ）<br>A. 方法实现<br>B. 方法嵌套<br>C. 方法调用<br>D. 方法定义</p></li><li><p>(单选题)顺序图是强调消息随时间顺序变化的交互图，下面不是用来描述顺序图的组成部分的是（   D   ）。<br>A. 类角色<br>B. 生命线<br>C. 消息<br>D. 转换</p></li><li><p>(单选题)顺序图反映对象之间发送消息的时间顺序，它与（  C    ）是同构的。<br>A. 用例图<br>B. 类图<br>C. 协作图<br>D. 状态图</p></li><li><p>(单选题)在UML的顺序图中，通常由左向右分层排列各个对象，正确的排列方法是（  A ）<br>A. 执行者角色、控制类、用户接口、业务层、后台数据库<br>B. 执行者角色、用户接口、控制类、业务层、后台数据库<br>C. 执行者角色、控制类、用户接口、后台数据库、业务层<br>D. 执行者角色、用户接口、业务层、控制类、后台数据库</p></li><li><p>(单选题)消息的组成不包括（   A  ）<br>A. 接口<br>B. 活动<br>C. 发送者<br>D. 接收者</p></li><li><p>(单选题)多对象是UML哪个视图中的概念（  C ）<br>A. 类图<br>B. 状态图<br>C. 协作图<br>D. 组件图</p></li><li><p>(单选题)顺序图中的消息是以（ A ）顺序排列的。<br>A. 时间<br>B. 调用<br>C. 发送者<br>D. 接收者</p></li><li><p>(单选题)顺序图的作用有（B）。<br>A. 确认和丰富一个使用语境的逻辑表达<br>B. 细化用例的表达<br>C. 有效的描述如何分配各个类的职责，以及这些类具有相应职责的原因<br>D. 显示在交互过程中各个对象之间的组织交互关系及对象彼此之间的连接</p></li><li><p>(单选题)下列关于生命线的说法不正确的是（ D ）。<br>A. 生命线是一条垂直的虚线，用来表示顺序图中的对象在一段时间内存在<br>B. 在顺序图中，每个对象的底部中心的位置都带有生命线<br>C. 在顺序图中，生命线是一条时间线，从顺序图的顶部一直延伸到底部，所用时间取决于交互持续的时间，即生命线表现了对象存在的时段<br>D. 顺序图中的所有对象在程序一开始运行的时候，其生命线都必须存在</p></li><li><p>(单选题)在UML的顺序图中将交互关系表现成一幅二维图，其中纵向是（A），横向是（A）。<br>A. 时间、对象角色<br>B. 交互、消息<br>C. 时间、消息<br>D. 交互、泛化</p></li><li><p>(单选题)下列关于顺序图的说法不正确的是（D）。<br>A. 顺序图是对象之间传送消息时间顺序的可视化表示<br>B. 顺序图比较详细地描述了用例表达的需求<br>C. 顺序图的目的在于描述系统中各个对象按照时间顺序的交互<br>D. 在顺序图中，消息表示一组在对象间传递的数据，不能代表调用</p></li></ol><h1 id="第九章选择题"><a href="#第九章选择题" class="headerlink" title="第九章选择题"></a>第九章选择题</h1><ol><li><p>(单选题)关于协作图的描述，下列哪个不正确（　B　　）<br>A. 协作图作为一种交互图，强调的是参加交互的对象的组织<br>B. 协作图是顺序图的一种特例<br>C. 协作图中有消息流的顺序号<br>D. 在ROSE中，协作图可在顺序图的基础上按F5键自动生成</p></li><li><p>(单选题)在UML中，协作图的组成不包括（  C  ）<br>A. 对象<br>B. 消息<br>C. 发送者<br>D. 链</p></li><li><p>(单选题)下列选项中不属于通信图与顺序图的共同点的是（ D ）。<br>A. 表达语义相同，都是对系统中的交互建模<br>B. 对象责任相同，都担任发送者和接受者的角色<br>C. 主要元素相同，都是对象与消息作为主要元素<br>D. 对象表示相同，都可以显示地体现出对象的生命周期</p></li><li><p>(单选题)在通信图中用来连接对象与对象的元素是（B）。<br>A. 关联关系<br>B. 链<br>C. 生命线<br>D. 消息</p></li><li><p>(单选题)下列关于通信图中链的叙述，正确的是（A）。<br>A. 通信图中的链和对象图中的链在语义及表示法上相同<br>B. 在通信图中，链一定连接了两个不同的对象<br>C. 在通信图中，链可以添加可见性修饰来表示两端对象对整条链的可见性<br>D. 通信图中对象之间的链一定在整个软件的生命周期内都存在</p></li></ol><h1 id="第十章选择题"><a href="#第十章选择题" class="headerlink" title="第十章选择题"></a>第十章选择题</h1><ol><li><p>(单选题)若将活动状态比作方法，那么动作状态即（  C ）<br>A. 方法名<br>B. 方法返回值<br>C. 方法体中的每一条语句<br>D. 方法的可见性</p></li><li><p>(单选题)事件（event）表示对一个在时间和空间上占据一定位置的有意义的事情的规格说明，下面哪个不是事件的类型（  C  ）<br>A. 信号<br>B. 调用事件<br>C. 源事件<br>D. 时间事件</p></li><li><p>(单选题)下列关于状态图的说法中，正确的是（  C　）<br>A. 状态图是UML中对系统的静态方面进行建模的五种图之一<br>B. 状态图是活动图的一个特例，状态图中的多数状态是活动状态<br>C. 活动图和状态图是对一个对象的生命周期进行建模，描述对象随时间变化的行为。<br>D. 状态图强调对有几个对象参与的活动过程建模，而活动图更强调对单个反应型对象建模</p></li><li><p>(单选题)对反应型对象建模一般使用（  A ）图<br>A. 状态图<br>B. 顺序图<br>C. 活动图<br>D. 类图</p></li><li><p>(单选题)状态图包括（   D   ）<br>A. 类的状态和类执行的动作<br>B. 状态之间的转换<br>C. 触发类的动作的事件<br>D. 以上所有选项</p></li><li><p>(单选题)下列对状态图描述不正确的是 (  C  )<br>A. 状态图通过建立类对象的生命周期模型来描述对象随时间变化的动态行为<br>B. 状态图适用于描述状态和动作的顺序，不仅可以展现一个对象拥有的状态，还可与说明事件如何随着时间的推移来影响这些状态<br>C. 状态图的主要目的是描述对象创建和撤销过程中资源的不同状态，有利于开发人员提高开发效率<br>D. 状态图描述了一个实体基于事件反映的动态行为，显示了该如何根据当前所处状态对不同事件做出反应</p></li><li><p>(单选题)组成一个状态的多个子状态之间是互斥的，不能同时存在，那么这种状态称为（ A ）复合状态。<br>A. 顺序<br>B. 并发<br>C. 历史<br>D. 同步</p></li><li><p>(单选题)假设在某个状态的内部的一行内容表示为“eventA&#x2F;defer”，则这行内容所表示的是（ D ）。<br>A. 触发器<br>B. 内部转换<br>C. 内部执行活动<br>D. 可推迟事件</p></li><li><p>(单选题)下列说法不正确的是（D）。<br>A. 触发器事件就是能够引起状态转换的事件，触发器事件可以是信号或者调用等<br>B. 没有触发器事件的转换是由状态活动的完成引起的<br>C. 内部转换默认不激发入口和出口动作，因此内部转换激发的结果不改变本来状态<br>D. 状态机图的主要目的是描述对象创建和销毁过程中资源的不同状态，有利于开发人员提高开发效率</p></li><li><p>(单选题)假设一个转换被表示为“A［B］&#x2F;C”，那么这个转换所表达的语义是（B）<br>A. 该转换的触发器事件为B，监护条件为A，效果列表为C<br>B. 该转换的触发器事件为A，监护条件为B，效果列表为C<br>C. 该转换的触发器事件为C，监护条件为A，效果列表为B<br>D. 该转换的触发器事件为A，监护条件为C，效果列表为B</p></li><li><p>(单选题)需要依赖于某个表达式所表达的布尔条件才能发生的事件被称作（ C ）。<br>A. 信号事件<br>B. 调用事件<br>C. 改变事件<br>D. 时间事件</p></li><li><p>(单选题)状态机图的意义是（A）<br>A. 对实体在其生命周期中的各个状态进行建模，状态是实体在一段时间内保持的一个状态<br>B. 将系统的需求转化成图形表示，简单直观，还可以转化成程序的伪代码<br>C. 表示两个或多个对象之间的独立连接，是不同对象不同时期情况的图形化描述<br>D. 描述对象和对象之间按时间顺序的交互行为</p></li><li><p>(单选题)下列选项不属于伪状态的是（B）<br>A. 历史状态<br>B. 复合状态<br>C. 初态<br>D. 选择</p></li></ol><h1 id="第十一章活动图"><a href="#第十一章活动图" class="headerlink" title="第十一章活动图"></a>第十一章活动图</h1><ol><li><p>(单选题)（ A  ）技术是将一个活动图中的活动状态进行分组，每一组表示一个特定的类、人或部门，他们负责完成组内的活动。<br>A. 泳道<br>B. 交叉汇合<br>C. 分支<br>D. 转移</p></li><li><p>(单选题)下列关于状态图的说法中，正确的是（  C　）<br>A. 状态图是UML中对系统的静态方面进行建模的五种图之一<br>B. 状态图是活动图的一个特例，状态图中的多数状态是活动状态<br>C. 状态图和活动图是对对象的生命周期进行建模，描述对象随时间变化的行为<br>D. 状态图强调对有几个对象参与的活动过程建模，而活动图更强调对单个反应型对象建模。</p></li><li><p>(单选题)下面不是活动图中的基本元素的是（   D   ）。<br>A. 状态、分支<br>B. 分叉、汇合<br>C. 泳道、对象流<br>D. 用况、状态</p></li><li><p>(单选题)以下说法错误的是（C）。<br>A. 活动图中的开始标记一般只有一个，而终止标记可能有多个<br>B. 判断节点的出口条件必须保证不互相重复，并且不缺少情况<br>C. 在活动图中并没有表现出并发，在实际实现的时候一定不涉及并发问题<br>D. 活动图比状态图更加合适去描述一个流程</p></li><li><p>(单选题)下列建模需求中，适合使用活动图来完成的是（C）。<br>A. 对体系结构建模<br>B. 对消息流程建模<br>C. 对业务流程建模<br>D. 对数据库模式建模</p></li><li><p>(单选题)在活动图中负责在一个活动节点执行完毕后切换到另一个节点的元素是（A）。<br>A. 控制流<br>B. 对象流<br>C. 判断节点<br>D. 扩展区域</p></li><li><p>(单选题)若想在活动图中表现对象流，则首先需要绘制出（C）元素。<br>A. 控制流<br>B. 分叉节点<br>C. 泳道<br>D. 扩展区域</p></li><li><p>(单选题)以下哪一项信息不容易在活动图中表达？（D）<br>A. 动作执行顺序<br>B. 动作的执行者<br>C. 活动进行的逻辑结构<br>D. 执行者之间的交互</p></li><li><p>(单选题)在活动图中用于连接动作或节点，表示活动进行方向的元素是（A）。<br>A. 控制流<br>B. 对象流<br>C. 动作<br>D. 扩展区域</p></li><li><p>(单选题)在活动图中用于对元素按照负责对象分组的元素是（A）。<br>A. 判断节点<br>B. 泳道<br>C. 分叉节点<br>D. 控制流</p></li><li><p>(单选题)在活动图中用于将判断节点产生的多个控制流合成并导出为一个控制流的元素是（D）。<br>A. 分叉节点<br>B. 结合节点<br>C. 判断节点<br>D. 合并节点</p></li><li><p>(单选题)活动图中可能出现的终止标记的数量是（B）。<br>A. 0<br>B. 0到多个<br>C. 1<br>D. 0或1</p></li><li><p>(单选题)在活动图中包含并发含义的元素主要指的是（D）。<br>A. 控制流<br>B. 判断节点<br>C. 泳道<br>D. 分叉节点</p></li></ol><h1 id="第十二章选择题"><a href="#第十二章选择题" class="headerlink" title="第十二章选择题"></a>第十二章选择题</h1><ol><li><p>(单选题)组件图用于对系统的静态实现视图建模，这种视图主要支持系统部件的配置管理，通常可以分为四种方式来完成，下面哪种不是其中之一（　B　）<br>A. 对源代码建模<br>B. 对事物建模<br>C. 对物理数据库建模<br>D. 对可适应的系统建模</p></li><li><p>(单选题)组件图专注于系统的（ B  ）实现图<br>A. 动态<br>B. 静态<br>C. 基础<br>D. 实体</p></li><li><p>(单选题)（ B  ）是被节点执行的事物<br>A. 包<br>B. 组件<br>C. 接口<br>D. 节点</p></li><li><p>(单选题)（ D   ）是可复用的，提供明确接口完成特定功能的程序代码块。<br>A. 模块<br>B. 函数<br>C. 用例<br>D. 软件构件</p></li><li><p>(单选题)（  D  ）是系统中遵从一组接口且提供实现的一个物理部件，通常指开发和运行时类的物理实现<br>A. 部署图<br>B. 类<br>C. 接口<br>D. 组件</p></li><li><p>(单选题)构件图的组成不包括 (   C  )<br>A. 接口<br>B. 构件<br>C. 发送者<br>D. 依赖关系</p></li><li><p>(单选题)UML 中的构件是遵从一组接口并提供一组接口的实现，下列说法错误的是(  B  )。<br>A. 构件应是可替换的<br>B. 构件表示的是逻辑模块而不是物理模块<br>C. 构件应是组成系统的一部分<br>D. 构件与类处于不同的抽象层次</p></li></ol><h1 id="第十三章选择题"><a href="#第十三章选择题" class="headerlink" title="第十三章选择题"></a>第十三章选择题</h1><ol><li><p>(单选题)部署图的组成不包括（C）<br>A. 处理器<br>B. 设备<br>C. 构件<br>D. 连接</p></li><li><p>(单选题)下列说法正确的是（D）<br>A. 部署就是复制软件<br>B. 软件的执行环境一般是一个独立的设备节点<br>C. 部署图不适用于分布式系统<br>D. 节点之间一般会存在通信</p></li><li><p>(单选题)软件部署的实质是（D）<br>A. 部署软件组件<br>B. 部署软件程序<br>C. 部署软件模型<br>D. 部署软件制品</p></li><li><p>(单选题)下列关于部署图的说法不正确的是（B）<br>A. 部署图描述了一个系统运行时的硬件节点，这些节点上运行的软件构件将在何处物理运行，以及它们将如何彼此通信的静态视图<br>B. 每一个系统模型中可以包含多个部署图<br>C. 在一个部署图中包含了两种基本的模型元素：节点和节点之间的连接<br>D. 每一个系统模型中应该仅包含一个部署图</p></li><li><p>(单选题)某系统部署时需要一台LED显示屏，其在部署图中应该被建模为（A）类型节点<br>A. 设备<br>B. 处理器<br>C. 二者均可<br>D. 都不适用</p></li></ol><h1 id="第十四章选择题"><a href="#第十四章选择题" class="headerlink" title="第十四章选择题"></a>第十四章选择题</h1><ol><li><p>(单选题)RUP中有（   C  ）个核心过程工作流。<br>A. 1<br>B. 3<br>C. 6<br>D. 9</p></li><li><p>(单选题)定义大多数的需求和范围的工作是在RUP中的(  B  )阶段完成的。<br>A. 初始阶段<br>B. 细化阶段<br>C. 构造阶段<br>D. 提交阶段</p></li><li><p>(单选题)下列(  D )不在RUP的初始阶段中完成的<br>A. 编制简要的愿景文档<br>B. 粗略评估成本<br>C. 定义大多数的需求<br>D. 业务案例</p></li><li><p>(单选题)估计项目时长、对项目进行风险评估一般是（A）进行的工作。<br>A. 起始阶段<br>B. 细化阶段<br>C. 构建阶段<br>D. 转化阶段</p></li><li><p>(单选题)下列有关核心工作流的描述有误的是（C）。<br>A. 在分析和设计工作流中需要考虑系统的运行时性能，以及用户需求的满足程度<br>B. 实现工作流就是编程实现各个组件的过程<br>C. 部署工作流需要输出完整产品，并对组件进行单元测试<br>D. 配置和变更管理工作流描述了开发团队应当如何掌握数量庞大的制品</p></li><li><p>(单选题)下列选项中，不是迭代过程的优势的一项是（C）。<br>A. 可以更早地弱化风险<br>B. 更灵活地处理各种变化<br>C. 可以建立更抽象的软件架构<br>D. 开发团队不必一次完成所有工作，可以在工作的过程中学习和调整</p></li><li><p>(单选题)统一软件开发过程共有九个核心工作流，以下（D）不是RUP的核心工作流。<br>A. 需求工作流<br>B. 实现工作流<br>C. 测试工作流<br>D. 架构工作流</p></li><li><p>(单选题)RUP建议使用这个句式来描述过程： “谁在什么时候要用什么方法，做什么”，其中“做什么”对应着静态结构中的（C）元素。<br>A. 工作者<br>B. 活动<br>C. 制品<br>D. 工作流</p></li><li><p>(单选题)统一软件开发过程RUP共存在四个阶段，以下（B）不是RUP的阶段之一。<br>A. 起始阶段<br>B. 策划阶段<br>C. 构建阶段<br>D. 转化阶段</p></li></ol><h1 id="第一章简答题"><a href="#第一章简答题" class="headerlink" title="第一章简答题"></a>第一章简答题</h1><ol start="17"><li><p>(简答题)什么是对象间的可见性？<br>可见性指的是一个对象能够“看到”或者引用另一个对象的能力。</p></li><li><p>(简答题)简述面向对象分析方法（OOA）的5个基本步骤。<br>识别对象（包括标识潜在的对象和筛选对象两步）；识别对象的属性；识别对象的行为；识别对象所属的类；定义主题词。</p></li><li><p>(简答题)软件工程的目标有哪些？<br>使软件开发的成本能够控制在预计的合理范围内；使软件产品的各项功能和性能都能够满足用户需求；提高软件产品的质量；提高软件产品的可靠性；使生产出来的软件产品便于移植、维护、升级和适用；使软件产品的开发周期能够控制在预计的合理时间范围内。</p></li><li><p>(简答题)什么是面向对象方法？简述其优势。<br>面向对象方法就是主张从客观世界固有的事物出发来构建系统，提倡用人类在现实生活中常用的思维方法来认识、理解和描述客观事物，强调最终建立的系统能够映射问题域，也就是说，系统中的对象以及对象之间的关系能够如实反映问题域中固有的事物及其关系。</p></li><li><p>(简答题)简述对象、类、抽象、封装、泛化与多态的概念。<br>对象：一个具有状态、行为和标识符的实体，并且对象之间往往可以通过通信相互交互。</p></li></ol><p>类：拥有共同的结构、行为和语义的一组对象的抽象。</p><p>抽象：揭示一个事物区别于其他事物的本质特征，去除从某一角度看来不重要的细节的行为。</p><p>封装：对其客户隐藏对象的属性和实现细节，仅对外公开接口，并控制在程序中属性的读取和修改的访问级别。</p><p>泛化：类元的一般描述和具体描述之间的关系，具体描述建立在一半描述的基础之上，并对其进行了扩展。</p><p>多态：在同一接口下表现多种行为的能力，是面向对象技术的根本特征。</p><ol start="22"><li>(简答题)简述软件危机产生的原因？<br>随着软件规模的扩大，复杂性的增加，功能的增强，使用早期的自由软件开发方式使得高质量的软件开发变得越来越困难。</li></ol><h1 id="第二章简答题"><a href="#第二章简答题" class="headerlink" title="第二章简答题"></a>第二章简答题</h1><ol start="19"><li><p>(简答题)简述统一建模语言(UML)<br>统一建模语言(UML)是一种绘制软件蓝图的标准语言。可以用UML对软件密集型系统的制品进行可视化详述和文档化。UML是一种定义良好、易于表达、功能强大且普遍适用的可视化建模语言。它融入了软件工程领域的新思想、新方法和新技术。它的作用域不限于支持面向对象的分析与设计，还支持从需求分析开始的软件开发的全过程。UML的作用就是用很多图从静态和动态方面来全面描述我们将要开发的系统。</p></li><li><p>(简答题)简述建模的几点基本原理。<br>第一，选择创建什么模型对如何解决问题和如何形成相应解决方案意义深远。第二，可以在不同的层次级别上表示不同模型。第三，最好的模型总是与现实世界联系密切。第四，单个模型或视图是不充分的。</p></li><li><p>(简答题)谈谈统一建模语言出现的意义<br>UML的出现可以帮助开发团队以一种可视化的方式理解系统的功能需求。UML统一了各种方法对不同类型的系统、不同开发阶段以及不同内部概念的不同观点，从而有效地消除了各种建模语言之间不必要的差异。UML建模能力比其他面向对象建模方法更强。它不仅适合于一般系统的开发，而且对并行、分布式系统的建模尤为适宜。使用UML使硬件组件和软件组件之间将会有更大的透明度。便携性和综合效率将会增加。</p></li><li><p>(简答题)简述UML的应用范围<br>UML最广泛的应用是对软件系统进行建模，但它同样适用于许多非软件系统领域的系统。当UML应用于大多数软件系统的开发过程时，它从需求分析阶段到系统完成后的测试阶段都能起到重要作用。</p></li><li><p>(简答题)什么是模型？为什么为软件系统建模非常重要？<br>模型是用某种媒介对相同媒介或其他媒介里的一些事物的表现形式。建模对一个系统的作用包括： 捕获和精确表达项目的需求和应用领域的知识，以使全部涉众能够理解并达成一致； 完成系统设计； 分离需求与具体实现细节； 帮助生成有用的工作产品； 方便研究多种解决方案； 全面把握复杂的系统。</p></li></ol><h1 id="第三章简答题"><a href="#第三章简答题" class="headerlink" title="第三章简答题"></a>第三章简答题</h1><ol start="24"><li><p>(简答题)简述UML中四种基本关系的含义和作用。<br>UML中的四中关系包括关联关系、依赖关系、泛化关系和实现关系。 关联关系用来描述不同类元的实例之间的连接。它是一种结构化的关系，指一种对象和另一种对象之间存在联系，即“从一个对象可以访问另一个对象”。 依赖关系用来描述一对模型元素之间的内在联系（语义关系）。 泛化关系类似于面向对象方法中的继承关系，是从特殊到一般的一种归纳和分类关系。 实现关系是用来描述规格说明和其实现的元素之间的连接的一种关系。其中规格说明定义了行为的说明，真正的实现由后一个模型元素来完成。</p></li><li><p>(简答题)简述“4+1”视图中五种视图的作用。<br>“4+1”视图包括逻辑视图、开发视图、进程视图、物理视图和场景视图。 逻辑视图将系统功能进行分解，负责反映出系统内部是如何组织和协作来实现功能的。 开发视图主要用来描述软件的各个模块的组织方式，包括源程序、程序包、支持软件、第三方库等。 进程视图主要描述系统的运行特性，侧重系统的性能和稳定性，关心系统的并发性、分布性、集成性的好坏，主要关注进程、线程、对象，并发、同步、通信等运行时概念。 物理视图主要描述硬件配置，强调系统的安装、配置、通信、拓扑结构等问题。 场景视图从项目需求入手，将四个视图结合为一个整体。可以描述一个特定视图内的构件关系，也可以描述不同视图间的构件关系。</p></li><li><p>(简答题)简述UML中的四种事物的含义和作用。<br>UML中的四种事物包括结构事物、行为事物、分组事物和注释事物。 结构事物通常作为UML模型的静态部分，用于描述概念元素或物理元素。 行为事物是UML模型的动态部分，用于描述UML模型中的动态元素，主要为静态元素之间产生的时间和空间上的行为动作，类似于句子中动词的作用。 分组事物是UML模型的组织部分，是用来组织系统设计的事物。 注释事物是UML模型的解释部分。这些注释事物用来描述、说明和标注模型的任何元素，简言之，就是对UML中元素的注释。</p></li></ol><h1 id="第四章简答题"><a href="#第四章简答题" class="headerlink" title="第四章简答题"></a>第四章简答题</h1><ol start="30"><li>(简答题)学生管理系统中有一个模块是报到登记，具体流程是：在新生入校报到时，进行新生信息登记，记录学生的报到资料、个人基本情况的输入、查询、修改等。问题： 1.　写出在上述需求描述中出现的Actor   2.　根据上述描述绘制其用例图<br><img src="https://img-blog.csdnimg.cn/a543ea0ee01c4385841839d7c1a1c0f3.png" alt="在这里插入图片描述"></li><li>(简答题)请选择UML中合适的图来描述图书管理系统中图书馆业务功能模块。该模块包括借书，还书，预约借书等功能<br><img src="https://img-blog.csdnimg.cn/bd955d17c64f46b2ac3cc8d55236223c.png" alt="在这里插入图片描述"></li><li>(简答题)网络的普及带给了人们更多的学习途径，随之而来的管理远程网络教学的“远程网络教学系统”诞生了。“远程网络教学系统”的功能需求如下： 1.学生登录网站后，可以浏览课件、查找课件、下载课件、观看教学视频。 2.教师登录网站后，可以上传课件、上传教学视频、发布教学心得、查看教学心得、修改教学心得。 3.系统管理员负责对网站页面的维护、审核不合法课件和不合法教学信息、批准用户注册。 （1）学生需要登录“远程网络教学系统”后才能正常使用该系统的所有功能。如果忘记密码，可与通过“找回密码”功能恢复密码。请画出学生参与者的用例图。 （2）教师如果忘记密码，可以通过“找回密码”功能找回密码。请画出教师参与者的用例图。<br><img src="https://img-blog.csdnimg.cn/23ecd05524634115ae393469457ffbb1.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/963336bf56734f778e7d1ab8ec329e44.png" alt="在这里插入图片描述"></li><li>(简答题)简述用例模型的组成元素以及建模步骤<br>组成元素有：参与者，用例，通信关联，用例规约</li></ol><p> 建立用例模型步骤： (1)根据系统边界确定参与者 (2)根据每个参与者确定与之相关联的用例 (3)对每个用例写出用例规约文档，调整用例模型（优化参与者与参与者之间的关系，用例与用例之间的关系）</p><ol start="34"><li><p>(简答题)什么是用例描述？用例描述包括哪些主要部分？<br>用例描述即通过使用足够清楚的、便于理解的文字来描述一个事件流，进而来说明一个用例的行为。一般的用例描述主要包括用例名称、用例编号、参与者、用例描述、触发器、前置条件、基本事件流、扩展事件流、结论、后置条件、补充约束。</p></li><li><p>(简答题)用例和用例之间存在什么关系，分别在什么时候使用？<br>用例之间的关系包括泛化关系和依赖关系。 用例间的泛化关系用来表示一般用例与特殊用例间的关系。用例间最常见的两种依赖关系为包含与扩展。包含指的是基用例可以包含用例具有的行为，其中包含用例中定义的行为将被插入基用例定义的行为中。扩展指的是扩展用例对基用例行为的增强。在这一关系中，扩展用例包含了一个或多个片段，每个片段都可以插入到基用例中的一个单独的位置上，而基用例对于扩展的存在是毫不知情的。</p></li></ol><h1 id="第五章简答题"><a href="#第五章简答题" class="headerlink" title="第五章简答题"></a>第五章简答题</h1><ol start="29"><li>(简答题)请根据下面的用例图设计相关类图</li></ol><p><img src="https://img-blog.csdnimg.cn/d0e7198953e44bf1a2bfcae7642c9208.png" alt="在这里插入图片描述"><br>30. (简答题)已知三个类A.B和C.其中类A由类B的一个实体类和类C的1个或多个实体类构成。请画出能够正确表示类A,B和C之间关系的UML类图.<br><img src="https://img-blog.csdnimg.cn/4367cfbf9a544ace8cdd113bc2f06b60.png" alt="在这里插入图片描述"></p><h1 id="第六章简答题"><a href="#第六章简答题" class="headerlink" title="第六章简答题"></a>第六章简答题</h1><ol start="10"><li>(简答题)对于Vehicle（车）类和Wheel（轮子）类，存在一个一对多的关联关系。试创建一个Vehicle类的三轮车对象，与三个轮子对象存在链，有一个前轮和两个后轮。用对象图表示三轮车对象与轮子对象之间的关系。<br><img src="https://img-blog.csdnimg.cn/b3defca7199b48aaa30845c1fd83ba2a.png" alt="在这里插入图片描述"></li><li>(简答题)在某出版系统中，存在出版社、图书、作者三个实体类。试对一图书对象创建对象图，并在图中表示出其与出版社对象及作者对象之间的关系。<br><img src="https://img-blog.csdnimg.cn/edc40c7364c44c3e8254a70d57a91cb2.png" alt="在这里插入图片描述"></li></ol><h1 id="第七章简答题"><a href="#第七章简答题" class="headerlink" title="第七章简答题"></a>第七章简答题</h1><ol start="15"><li>(简答题)在某系统中存在三个逻辑部分，分别是Business包、DataAccess包和Common包，其中Business包需要导入DataAccess包和Common包，DataAccess包需要导入Common包。在类图中试着创建这些包，并绘制其关系。<br><img src="https://img-blog.csdnimg.cn/f94451391978470f90af1263fde6d880.png" alt="在这里插入图片描述"></li></ol><h1 id="第八章简答题"><a href="#第八章简答题" class="headerlink" title="第八章简答题"></a>第八章简答题</h1><ol start="22"><li>(简答题)图书管理系统功能性需求说明如下: 1.图书管理系统能够为一定数量的借阅者提供服务。每个借阅者能够拥有唯一标识其存在的编号。图书馆向每一个借阅者发放图书证，其中包含每一个借阅者的编号和个人信息。提供的服务包括：提供查询图书信息、查询个人信息服务和预定图书服务等。 2.当借阅者需要借阅图书、归还书籍时需要通过图书管理员进行，即借阅者不直接与系统交互，而是通过图书管理员充当借阅者的代理和系统交互。 3.系统管理员主要负责系统的管理维护工作，包括对图书、数目、借阅者的添加、删除和修改。并且能够查询借阅者、图书和图书管理员的信息。 4.可以通过图书的名称或图书的ISBN&#x2F;ISSN号对图书进行查找。 回答下面问题： (1)该系统中有哪些参与者? (2)确定该系统中的类，找出类之间的关系并画出类图 (3)画出语境“借阅者预定图书”的时序图</li></ol><p>该系统中有哪些参与者?借阅者  图书管理员   系统管理员</p><p>确定该系统中的类，找出类之间的关系并画出类图</p><p>用户类、用户角色类、图书类、预定类、借阅类、书目类<br><img src="https://img-blog.csdnimg.cn/96e57180ccb14b289a0ed076bcdecfa4.png" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/2cc0b84a90c94177bc8a4fcc4013255f.png" alt="在这里插入图片描述"><br>23. (简答题)在某一学生指纹考勤系统中，有一个用例名为“上课登记”。此用例允许学生在上课前使用系统识别自己的指纹信息进而识别自己的身份，同时系统可以将登录信息存储在数据库中。 “上课登记”用例的主要事件流如下：  学生从系统菜单中选择“上课登记”；  系统显示指纹识别界面；  学生将手指放置于界面上；  系统捕获并识别学生的指纹，向学生返回识别的身份信息；  学生选择“确认”按钮； 系统生成一个关于该登记学生及当前日期、时间的新记录，并将该记录保存到数据库中。 请根据以上描述绘制“上课登记”用例的顺序图。<br><img src="https://img-blog.csdnimg.cn/f97a9f22484241e28c64b472964dec32.png" alt="在这里插入图片描述"></p><h1 id="第九章简答题"><a href="#第九章简答题" class="headerlink" title="第九章简答题"></a>第九章简答题</h1><ol start="16"><li>(简答题)（1） 某银行系统存款处理过程如下： ① 系统将存款单上的存款金额分别记录在存折和账目文件中。 ② 将现金存入现金库。 ③ 最后将打印后的存折还给储户。 请分析此交互过程所涉及的系统对象，并结合存款处理流程绘制通信图。<br><img src="https://img-blog.csdnimg.cn/f8518f78696b43faa4ad6ed6b839c64f.png" alt="在这里插入图片描述"></li><li>(简答题)（2） 对于某在线购物系统，主要有以下三个交互过程。 ① 登录： 用户申请登录系统，系统验证用户身份的有效性。 ② 购物： 用户浏览系统的搜索页面，搜索到目标商品，并将之添加到购物车。 ③ 结算： 用户结算购物车内的所有商品，更新库存并创建订单。 绘制通信图来表示这三个交互过程。<br><img src="https://img-blog.csdnimg.cn/136b0fd02fc5410593538d34e8af6537.png" alt="在这里插入图片描述"></li></ol><h1 id="第十章简答题"><a href="#第十章简答题" class="headerlink" title="第十章简答题"></a>第十章简答题</h1><ol start="14"><li><p>(简答题)<br><img src="https://img-blog.csdnimg.cn/eee2ff876776451c9155b2881328cd6e.png" alt="在这里插入图片描述"><br>1.该图是什么图，其中的矩形框表示什么 2.该图描述了怎样的情形<br>状态图，表示就绪，运行，阻塞状态； 线程运行的基本流程如下： 当线程准备运行时，进入就绪状态，如果获得cpu时间片，就转入运行状态，运行正常结束，进入结束状态，如果在运行过程中，cpu时间片用完后还没有完成任务，就进入就绪状态，等待再次得到cpu时间片，如果线程在运行过程中，不满足所须资源，就进入阻塞状态，处于阻塞状态的线程得到相关资源后，进入就绪状态，依次循环。</p></li><li><p>(简答题)简述简单状态和复合状态的异同。<br>简单状态都是不包含嵌套子结构的； 而复合状态是指包含有一个或多个嵌套状态机的状态。</p></li><li><p>(简答题)当手机开机时，它处于空闲状态，当用户使用电话呼叫某人时，手机进入拨号状态。如果呼叫成功，即电话接通，手机就处于通话状态； 如果呼叫不成功，例如对方线路有问题或关机，则拒绝接听。这时手机停止呼叫，重新进入空闲状态，手机在空闲状态下被呼叫，手机进入响铃状态（ringing）； 如果用户接听电话（pick），手机处于通话状态； 如果用户未做出任何反应，可能他没有听见铃声，手机一直处于响铃状态； 如果用户拒绝来电，手机回到空闲状态。请按以上描述绘制出使用手机的状态机图。<br> <img src="https://img-blog.csdnimg.cn/58562e44ae934356864b8ff2e761ded8.png" alt="在这里插入图片描述"></p></li><li><p>(简答题)简单的数字手表表面上有一个显示屏和两个设置按钮A和B，有两种操作模式： 显示时间和设定时间。在显示时间模式下，手表会显示小时数和分钟数，小时数和分钟数由闪烁的冒号分隔。设定时间模式有两种子模式： 设定小时和设定分钟。按钮A选择模式，每次按下此按钮时，模式会连续前进： 设定小时、设定分钟等。在子模式内，每次只要按下按钮B，就会拨快小时或分钟。绘制一个数字手表的状态机图。<br> <img src="https://img-blog.csdnimg.cn/7bbca808dbd74101940f1776dc44a75e.png" alt="在这里插入图片描述"></p></li><li><p>(简答题)简述状态机图的组成要素。<br>状态机图的主要元素是状态，各状态由转移连接在一起。此外，伪状态和复合状态也是其组成元素。</p></li></ol><h1 id="第十一章简答题"><a href="#第十一章简答题" class="headerlink" title="第十一章简答题"></a>第十一章简答题</h1><ol start="24"><li><p>(简答题)简述活动图和普通流程图的异同。<br>事实上活动图是在流程图的基础上添加了大量软件工程术语而成的改进版。具体地说，活动图的表达能力包括了逻辑判断、分支甚至并发，所以活动图的表达能力要远高于流程图： 流程图仅仅展示一个固定的过程，而活动图可以展示并发和控制分支，并且可以对活动与活动之间信息的流动进行建模。可以说，活动图在表达流程的基础上继承了一部分协作图的特点，即可以适当表达活动之间的关系。</p></li><li><p>(简答题)某学生选课系统的查询课程用例如下： 学生首先进入选课系统，然后输入要查询的课程名，系统验证输入的课程名是否存在，若存在，则跳转到对应的显示课程信息的页面； 若不存在，则给出提示信息，返回选课页面。 请根据以上描述绘制活动图。<br><img src="https://img-blog.csdnimg.cn/20dc5dbae8d64ef2a74d2d611f04bd52.png" alt="在这里插入图片描述"></p></li><li><p>(简答题)在机票预订系统中，使用系统的用户必须先注册一个自己的账号，其过程为输入注册信息、验证信息完整、提交信息、系统进行验证（是否重名等等），如果验证均通过，则注册成功，否则失败。 请根据以上描述，对用户注册用例画出活动图。<br><img src="https://img-blog.csdnimg.cn/2ed4a47599164040a477ed31706d5ac6.png" alt="在这里插入图片描述"></p></li></ol><h1 id="第十二章简答题"><a href="#第十二章简答题" class="headerlink" title="第十二章简答题"></a>第十二章简答题</h1><ol start="15"><li><p>(简答题)已知某系统包括三个组件，分别命名为MainProg、PrintProg与Database。其中，PrintProg组件提供IPrint接口供MainProg使用，MainProg组件在运行时直接依赖于Database组件的存在。请对以上所描述的三个组件绘制出相应的组件图。<br><img src="https://img-blog.csdnimg.cn/5aaea39098154dfab4c552831d81347f.png" alt="在这里插入图片描述"></p></li><li><p>(简答题)目前住院病人主要由护士护理，这样做不仅需要大量护士，而且由于不能随时观察危重病人的病情变化，还会延误抢救时机。某医院打算开发一个以计算机为中心的患者监护系统。医院对患者监护系统的基本要求是随时接收每个病人的生理信号（脉搏、体温、血压、心电图等），定时记录病人情况，以形成患者日志。当某个病人的生理信号超出医生规定的安全范围时，向值班护士发出警告信息。此外，护士在需要时还可以要求系统打印出某个指定病人的病情报告。 设计阶段拟将系统分为五个主要组件： 用户界面、系统控制、病人监护、患者日志实体与数据库。请根据情境描述，结合设计阶段提出的五个组件绘制组件图。</p></li></ol><p>首先确定出系统所需的五个组件： UserInterface、SystemController、Entity、PatientObserver以及Database。其中Entity组件需要依赖于Database组件，SystemController组件和PatientObserver组件均需要依赖于Entity组件，UserInterface组件要依赖于SystemController组件和PatientObserver组件。<br><img src="https://img-blog.csdnimg.cn/1f787bc44ee6449395741ec6c858d1d7.png" alt="在这里插入图片描述"></p><h1 id="第十三章简答题"><a href="#第十三章简答题" class="headerlink" title="第十三章简答题"></a>第十三章简答题</h1><ol start="11"><li><p>(简答题)简述部署图的建模方法。<br>部署图的意义在于对各种系统的静态部署视图进行建模。使用部署图对系统建模，可以遵循以下步骤： 将设备建模为节点； 使用构造型对不同种类的节点进行限制说明； 在节点之间建立关系； 添加注释和约束。</p></li><li><p>(简答题)某自动售货机系统部署时存在三个节点，分别为远程服务器、售货机、客户端。远程服务器负责一些数据存储工作； 售货机是自动售货机机器中的有处理和计算能力的部分； 客户端是机器中直接和用户进行交互的硬件部分。 其中售货机部分和客户端部分通过机器直接相连，售货机通过无线网络与远程服务器通信。 请根据以上描述绘制部署图。</p></li></ol><p>首先确定系统所需的三个节点： Client、SodaMachine与RemoteServer，其中Client节点是设备，另外两个节点是处理器。然后根据节点之间通信方式在节点之间建立带有构造型的关联。部署图可参考下图。<br><img src="https://img-blog.csdnimg.cn/5e5b6e727d2c47bab6c5ece18c353124.png" alt="在这里插入图片描述"><br>13. (简答题)为什么要将处理器和设备分开处理？谈谈你的理解。</p><p>既然我们把节点这些硬件资源纳入考虑当中，就必然少不了要从其特性出发来分析它们的运行时特性，如运算速度、内存大小等问题，因为这些问题可能是最终限制软件性能，或者强化软件运行效率的关键参数。这些节点的附加特性UML没有进行预定义，因此需要使用构造型或标记值自行创建。</p><h1 id="第十四章简答题"><a href="#第十四章简答题" class="headerlink" title="第十四章简答题"></a>第十四章简答题</h1><ol start="17"><li><p>(简答题)RUP统一过程中的四个阶段？<br>初始阶段 、细化阶段、构造阶段、提交阶段</p></li><li><p>(简答题)简述RUP的静态结构，并解释工作者、活动、制品和工作流的概念。<br>过程的静态结构即“谁在什么时候要用什么方法做什么”，包括工作者、活动、制品和工作流。 工作者定义了软件开发工作中某个工作单位的行为和责任，这个工作单位可能指某个个体，或者某个工作小组。 活动定义了一件事或一个动作，并且必须存在一个特定的工作者角色负责执行这个活动。 制品描述了一个过程中产生、修改或使用的事物。 工作流就是展示一个活动的可见价值的流程，可以描述活动的操作顺序以及工作者之间的交互关系等。</p></li><li><p>(简答题)简述RUP中的核心工作流。<br>在RUP中，软件开发的全过程被分划成九个核心工作流，每一项工作中的工作者和活动依照逻辑规则被列入某一个或几个工作流中。这九个核心工作流中，有六个属于核心工程工作流： 业务建模工作流、需求工作流、分析与设计工作流、实现工作流、测试工作流、部署工作流。而另外三个属于核心支持工作流： 项目管理工作流、配置与变更管理工作流、环境工作流。</p></li></ol><h1 id="第一章判断题"><a href="#第一章判断题" class="headerlink" title="第一章判断题"></a>第一章判断题</h1><ol start="9"><li>(判断题)对象的自治性指的是对象是完全封闭的，不受任何外界影响。 错</li><li>(判断题)类是面向对象程序中的构造単位，也是面向对象程序设计语言的基本成分。  对</li><li>(判断题)C语言对面向对象的发展起到了重要作用。 错</li><li>(判断题)面向对象方法中的对象是从客观世界中抽象出来的一个集合体。 对</li><li>(判断题)面向对象可以保证开发过程中的需求变化完全不会导致系统结构的变化。 错</li><li>(判断题)面向对象方法就是使用面向对象的程序设计语言进行编程。  错</li><li>(判断题)软件就是程序，编写软件就是编写程序。  错</li><li>(判断题)软件危机的只要表现就是软件需求增加，软件价格上升。  错</li></ol><h1 id="第二章判断题"><a href="#第二章判断题" class="headerlink" title="第二章判断题"></a>第二章判断题</h1><ol start="9"><li>(判断题)UML适用于以体系结构为中心的开发过程，但不适合在具有迭代特征的开发过程中使用。 错</li><li>(判断题)UML是一种直观化、明确化、构建和文档化软件产物的通用语言。    对</li><li>(判断题)UML提供了一些方法可以让用户创建出新的模型元素。  对</li><li>(判断题)在UML这个名称出现之前，James Rumbaugh和Grady Booch的合并OMT和Booch工作成果被称为UML0.8。   对</li><li>(判断题)1997年11月，UML 1.1规范被OMG全体成员通过，正式被采纳为规范。  对</li><li>(判断题)UML既是一门建模语言，也可以作为一门编程语言。   错</li><li>(判断题)在UML出现之前，众多不同的面向对象的方法同时存在，给用户带来了一定困扰。 对</li><li>(判断题)UML 2.0的出现彻底推翻了UML 1.x中的核心概念，发展成了一门与之前截然不同的建模语言。  错</li><li>(判断题)UML是一种建模语言，是一种标准的表示，是一种方法。   错</li><li>(判断题)UML支持面向对象的主要概念，并与具体的开发过程相关。  错</li></ol><h1 id="第三章填空题"><a href="#第三章填空题" class="headerlink" title="第三章填空题"></a>第三章填空题</h1><ol start="21"><li><p>(填空题)状态图和类图、顺序图不同之处在于，后两种图能够对______建立模型，而状态图只是对______建立模型。<br>(1) 多个对象<br>(2) 1个对象</p></li><li><p>(填空题)UML背后的两个重量级概念是______和______。<br>(1) 用例<br>(2) 面向对象</p></li><li><p>(填空题)软件体系结构是指一个系统的有目的的设计和规划，这个设计规划既不描述______，也不描述___ ，它只描述系统的 ___及其相互的______。<br>(1) 活动<br>(2) 系统怎样开发<br>(3) 组成元素<br>(4) 交互协作</p></li></ol><h1 id="第四章判断题"><a href="#第四章判断题" class="headerlink" title="第四章判断题"></a>第四章判断题</h1><ol start="18"><li>(判断题)在用例图中，Actor仅代表与目标系统进行交互的人。 错</li><li>(判断题)在两个用例中，如果一个用例拥有另一个用例的所有结构、行为和关系，并在此基础上增加了新的特性，则此两个用例之间可以用泛化关系表示。 对 </li><li>(判断题)用例的包含关系与扩展关系在表示法上相似，都是将虚线箭头从基用例指向包含用例（扩展用例）。 错</li><li>(判断题)如果两个用例构成包含关系，则在基用例执行过程中，包含用例一定会执行至少一次。  对</li><li>(判断题)用例元素本身就可以描述该用例所表达的事件或交互过程。   错</li><li>(判断题)用例描述中的前置条件与后置条件分别指的是用例执行前和执行后系统与参与者所处的状态。   对</li><li>(判断题)在用例图中，一个参与者一定对应于现实中的某个特定对象。   错</li><li>(判断题)用例图中的参与者可能对应于现实世界中的人，也可能是其他与系统有交互的事物。   对</li><li>(判断题)参与者就是那些为系统提供输入的人或事物。   错</li><li>(判断题)在用例图中，用例必须由相应的参与者来发起或执行。    对</li><li>(判断题)在绘制用例图时，其中用例的粒度越细越好。   错</li><li>(判断题)参与者位于系统边界外，并不是系统的一部分。   对</li></ol><h1 id="第五章判断题"><a href="#第五章判断题" class="headerlink" title="第五章判断题"></a>第五章判断题</h1><ol start="21"><li>(判断题)里氏替换原则的主要内容是“父类对于子类应该是完全可替换的”。   错</li><li>(判断题)假设班级类（Class）与学生类（Student）之间建立了关联关系，并且约定一个班级至少拥有一个学生，每个学生只能属于一个班级，则关联关系的班级类一端的多重性应设为1..*。   错</li><li>(判断题)在UML中，当接口使用小圆圈表示时，该接口与其他类的实现关系可以被简化为一条实线段。   对</li><li>(判断题)模板类在其参数未确定时，无法创建直接实例。   对</li><li>(判断题)类图主要通过系统中的类及类之间的关系来描述系统的动态结构。   错</li><li>(判断题)任何一个类都必须具有一定数量的属性与操作。   错</li><li>(判断题)接口中的操作不应该包含其具体实现。   对</li><li>(判断题)接口与抽象类的概念是完全相同的。   错</li></ol><h1 id="第六章判断题"><a href="#第六章判断题" class="headerlink" title="第六章判断题"></a>第六章判断题</h1><ol start="5"><li>(判断题)在UML中，对象和类的表示法完全相同。    错</li><li>(判断题)链是关联关系的实例，是两个或多个对象之间的独立连接。   对</li><li>(判断题)每一个对象图只是系统的静态设计视图或静态交互视图的图形表示。   对</li><li>(判断题)对象图显示了某一时刻的一组对象及它们之间的关系。   对</li><li>(判断题)类图可被看作是对象图的实例。   错</li></ol><h1 id="第七章判断题"><a href="#第七章判断题" class="headerlink" title="第七章判断题"></a>第七章判断题</h1><ol start="7"><li>(判断题)包之间表示依赖关系的虚线箭头指向被依赖的包的一方。   对</li><li>(判断题)包中可见性修饰为public的元素表示这些元素可以被项目中的所有包无条件地访问。   错</li><li>(判断题)包的路径名使用前缀来表示出上层包的名称。   对</li><li>(判断题)UML中的所有模型元素都可以被直接包含在包中。   对</li><li>(判断题)包内元素的可见性表示同一个包内的其他元素对该元素的访问权限。   错</li><li>(判断题)在UML中，每个元素只能被包含在一个包中。 对</li><li>(判断题)包只能用来组织UML中的事物，而无法用来组织UML图。   错</li><li>(判断题)包元素是UML中最重要的结构事物之一。   错</li></ol><h1 id="第八章判断题"><a href="#第八章判断题" class="headerlink" title="第八章判断题"></a>第八章判断题</h1><ol start="13"><li>(判断题)每条消息一定关联着至少两个不同的对象，即消息的发送者和接收者。   错</li><li>(判断题)在顺序图中，如果一个对象在接收到消息时还没有被激活，那么这条消息将会激活这个对象。    对</li><li>(判断题)顺序图虽然能表示消息发送的事件顺序，却无法量化地表示出消息发送的具体时间。   对</li><li>(判断题)顺序图中的对象可以在交互开始时已经存在，也可以在交互过程中才被创建。   对</li><li>(判断题)在顺序图中，对象的生命线一定会贯穿整个交互过程。   错</li><li>(判断题)在顺序图中，所有对象的生命线一定会被一个销毁标记所结束。   错</li><li>(判断题)激活表示在这一时间段内对象正在完成某项任务。   对</li><li>(判断题)顺序图从时间顺序上显示了交互过程中信息的交换。   对</li><li>(判断题)顺序图中元素的摆放顺序无关紧要。   错</li></ol><h1 id="第九章判断题"><a href="#第九章判断题" class="headerlink" title="第九章判断题"></a>第九章判断题</h1><ol start="6"><li>(判断题)因为通信图无法表示出对象在交互时的激活，顺序图也无法表示出交互过程中对象间的链，因此两种图所表达的语义是完全不等价的。   错</li><li>(判断题)与关联关系相似，UML也允许对象自身与自身之间建立一条链。   对 </li><li>(判断题)在通信图中，只有通过链连接的对象才能进行消息传递和交互。   错</li><li>(判断题)在通信图中出现的链是静态关联的实例。   错</li><li>(判断题)就语义和表示法而言，通信图中的消息与顺序图中的消息完全相同。   对</li><li>(判断题)通信图是表现对象协作关系的图，它展现了多个对象在协同工作达成共同目标的过程中互相通信的情况。    对</li><li>(判断题)通信图的主要组成元素包括对象、链、生命线和消息。   错</li><li>(判断题)通信图中应该表示出交互发生的时刻系统中存在的所有对象。   错</li><li>(判断题)由于交互时可能会有一组同类型的对象在交互中执行同一个操作，因此通信图提供了多重对象的概念。    对</li><li>(判断题)通信图将对象和时间作为两个维度在图中表示。   错</li></ol><h1 id="第十一章判断题"><a href="#第十一章判断题" class="headerlink" title="第十一章判断题"></a>第十一章判断题</h1><ol start="14"><li>(判断题)在活动图中，合并节点仅有逻辑意义而没有时间和数据上的意义。   对</li><li>(判断题)结合节点与合并节点相似，当控制流进行到该节点时都不需要等待其他控制流的到达。   错</li><li>(判断题)活动图可以像流程图一样表达出顺序、分支及循环控制结构，但语义要比流程图丰富得多。   对</li><li>(判断题)活动图可以在逻辑顺序角度对用例中的各个交互的流进行建模。   对</li><li>(判断题)活动图中必须有且只能有一个开始标记。   对</li><li>(判断题)活动图的控制流与状态图中的转换是语义完全相同的元素。   错</li><li>(判断题)泳道按活动发生的时间将活动图划分为几部分。   错</li><li>(判断题)一个活动不可能属于多个泳道。   对</li><li>(判断题)活动图是一种用于表达系统动态特性的UML图。   对</li><li>(判断题)活动本身是一个原子操作，是不可被中断的。   错</li></ol><h1 id="第十二章判断题"><a href="#第十二章判断题" class="headerlink" title="第十二章判断题"></a>第十二章判断题</h1><ol start="8"><li>(判断题)请求接口（Required Interface）用于定义一个构件所提供的服务。    错</li><li>(判断题)组件是组件图中语义最小的元素。   错</li><li>(判断题)组件是一个封装完好的物理实现单元，与外部完全分离。    对</li><li>(判断题)组件比类的抽象层次要高，类应该从属于某个组件。   对</li><li>(判断题)组件是系统工作产品的一部分，因此exe文件是一个组件，而程序的源文件不能作为一个组件。   错</li><li>(判断题)组件与其提供的接口之间构成依赖关系。   错</li><li>(判断题)在组件图中，组件之间的依赖关系表示组件在某些行为上的对其他组件的依赖。   对</li></ol><h1 id="第十三章判断题"><a href="#第十三章判断题" class="headerlink" title="第十三章判断题"></a>第十三章判断题</h1><ol start="6"><li>(判断题)部署图中节点之间的关联关系，可以对其应用构造型来表示不同类型的通信路径或者通信的实现方式。   对</li><li>(判断题)如果开发的软件只运行在一台机器上且所有与机器交互的设备都已经由操作系统进行连接，这类软件就不必对其设计部署图。   对</li><li>(判断题)部署图与组件图都是用来对系统的物理方面进行建模，因此二者所表达的语义是完全相同的。   错</li><li>(判断题)节点就是一台计算机      错</li><li>(判断题)在部署图中，节点之间可以建立来表示节点的通信      对</li></ol><h1 id="第十四章判断题"><a href="#第十四章判断题" class="headerlink" title="第十四章判断题"></a>第十四章判断题</h1><ol start="10"><li>(判断题)在起始阶段和转化阶段均可以使用到用例图。   对</li><li>(判断题)核心工作流在不同的阶段中可以有所重叠，但各个主要阶段不重叠。   对</li><li>(判断题)RUP的两个阶段之间交接的重要条件被称为迭代条件。   错</li><li>(判断题)RUP的核心工作流有九个，其中六个属于核心工程工作流，三个属于核心支持工作流   对</li><li>(判断题)RUP过程的静态结构通常用“活动”“制品”“参与者”和“工作流”的术语描述。   错</li><li>(判断题)迭代过程指的是在某一个工作流中重复执行工作。   错</li><li>(判断题)制品指的是软件产品，可以有测试版或发布版的可执行文件，但不包括文档。错</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 题库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot</title>
      <link href="/2023/08/18/SpringBoot/"/>
      <url>/2023/08/18/SpringBoot/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring-boot的配置文件和自动配置原理"><a href="#Spring-boot的配置文件和自动配置原理" class="headerlink" title="Spring boot的配置文件和自动配置原理"></a>Spring boot的配置文件和自动配置原理</h2><h3 id="配置文件的使用"><a href="#配置文件的使用" class="headerlink" title="配置文件的使用"></a>配置文件的使用</h3><h4 id="配置文件的介绍"><a href="#配置文件的介绍" class="headerlink" title="配置文件的介绍"></a>配置文件的介绍</h4><p>Spring Boot使用一个全局的配置文件 核心配置文件，配置文件名在约定的情况下名字是固定的:配置文件的作用: 修改SpringBoot自动配置的默认值; SpringBoot在底层都给我们自动配置好。</p><p>在spring boot框架中，resource文件夹里可以存放配置的文件有两种: properties和yml。</p><ol><li><p>application.properties的用法: 扁平的k&#x2F;v格式。</p><pre><code class="properties">server.port=8881server.servlet.context-path=/magichell</code></pre></li><li><p>application.yml的用法: 树型结构</p><pre><code class="yml">server:    port: 8088    servlet:        context-path: /magichell</code></pre></li></ol><p>两种前者是，而后者是yml的，建议使用后者，因为它的可读性更强。可以看到要转换成YML我们只需把properies里按.去拆分即可.</p><h4 id="yml的基础语法"><a href="#yml的基础语法" class="headerlink" title="yml的基础语法"></a>yml的基础语法</h4><p>k:(空格)v: 表示一对键值对(空格必须有)<br>以空格的缩进来控制层级关系;只要是左对齐的一列数据，都是同一个层级的属性和值也是大小写敏感，</p><h3 id="配置文件的加载顺序"><a href="#配置文件的加载顺序" class="headerlink" title="配置文件的加载顺序"></a>配置文件的加载顺序</h3><pre><code>&lt;includes&gt;    &lt;include&gt;**/application*.yml&lt;/include&gt;    &lt;include&gt;**/application*.yaml&lt;/include&gt;    &lt;include&gt;**/application*.properties&lt;/include&gt;&lt;/includes&gt;</code></pre><h3 id="外部约定配置文件加载顺序"><a href="#外部约定配置文件加载顺序" class="headerlink" title="外部约定配置文件加载顺序"></a>外部约定配置文件加载顺序</h3><h3 id="Spring-Boot-启动还会扫描以下位置的application-properties或者application-yml文件作为Spring-boot的默认配置文件"><a href="#Spring-Boot-启动还会扫描以下位置的application-properties或者application-yml文件作为Spring-boot的默认配置文件" class="headerlink" title="Spring Boot 启动还会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件"></a>Spring Boot 启动还会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</h3><p>低</p><ol><li><p>classpath根目录下的</p><p> ![屏幕截图 2023-08-19 101816](SpringBoot&#x2F;屏幕截图 2023-08-19 101816.png)</p><ol start="2"><li><p>classpath根config&#x2F;</p><p> ![](SpringBoot&#x2F;屏幕截图 2023-08-19 102345.png)</p><ol start="3"><li><p>项目根目录</p><p> 如果当前项目是继承&#x2F;耦合关系maven项目的话，项目根目象&#x3D;父maven项目的根目录</p><ol start="4"><li><p>项目根目录&#x2F;config </p><ol start="5"><li><p>直接子目录&#x2F;config</p><ol start="6"><li></li></ol><pre><code class="cmd">Java -jar configuration_file-0.0.1-SNAPSHOT.jar --spring.config.location=D:\config</code></pre></li></ol></li></ol></li></ol></li></ol></li></ol><p>高</p><p><strong>优先级由底到高，高优先级的配置会覆盖低优先级的配置，互补配置。</strong></p><h5 id="官网"><a href="#官网" class="headerlink" title="官网"></a>官网</h5><pre><code class="cmd">optional:classpath:/optional:classpath:/config/optional:file:./optional:file:./config/*/optional:file:./config/optional:classpath:custom-config/--spring.config.locationoptional:file:./custom-config/--spring.config.location</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/08/18/hello-world/"/>
      <url>/2023/08/18/hello-world/</url>
      
        <content type="html"><![CDATA[<h1 id="各类编程语言的第一个程序"><a href="#各类编程语言的第一个程序" class="headerlink" title="各类编程语言的第一个程序"></a>各类编程语言的第一个程序</h1><h2 id="Go"><a href="#Go" class="headerlink" title="Go"></a>Go</h2><p>代码示例</p><pre><code class="Go">package mainimport &quot;fmt&quot;func main() &#123;    fmt.Println(&quot;Hello, World!&quot;)&#125;</code></pre><p>运行结果</p>]]></content>
      
      
      
        <tags>
            
            <tag> hello </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础学习</title>
      <link href="/2023/08/18/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/18/Java%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="第一讲"><a href="#第一讲" class="headerlink" title="第一讲"></a>第一讲</h1><ul><li>javaSE：java Standard Edition</li><li>javaME：java Micro Edition</li><li>javaEE：java Enterprise Edition</li></ul><hr><p>JDK:java Development Kit（Java开发包）<br>JRE:java Runtime Environment(java执行环境)<br><strong>JDK包含了JRE</strong></p><hr><p>如何查询Java版本<br><code>java -version</code></p><p><img src="https://img-blog.csdnimg.cn/eb996522e4c347a2ba80a3b6cbefbceb.png" alt="在这里插入图片描述"></p><hr><p>实现你的第一个Java程序{Hello World}</p><ul><li><p>注：所有的Java代码，其后缀都是以Java结尾</p><pre><code class="Java">public class Text&#123;  public static void main &#123;String[] args&#125;&#123;       System.out.println(&quot;hello world&quot;);  &#125;&#125;</code></pre><p>java程序的执行过程分为两步</p></li></ul><ol><li>编译 <code>Javac Text.java</code></li><li>执行 <code>java Text</code><br>最后就会出现Hello World了</li></ol><hr><p><strong>class 文件是字节码文件，程序最终执行的就是这个字节码（bytecode）文件</strong></p><h1 id="第二讲"><a href="#第二讲" class="headerlink" title="第二讲"></a>第二讲</h1><p>java中的数据类型分为两类：</p><ol><li>原生数据类型 （primitive Data Type）</li><li>引用数据类型 ｛对象类型｝（Reference Type）</li></ol><hr><p> <strong>java中的原生数据类型共有8种</strong></p><ol><li>整型：使用int表示。</li></ol><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        int a;        a = 1;        System.out.println(a);        &#125;&#125;</code></pre><ol start="2"><li>字节型：使用byte表示。（表示-128~127之间的256个整数）</li></ol><pre><code class="java">public class Text&#123;    public static void main(String[] args)&#123;        byte b = 2;        System.out.println(b);    &#125;&#125;</code></pre><ol start="3"><li>短整型：使用short表示。（占比16位）</li><li>长整型：使用long表示。（占比64位）</li><li>单精度浮点型：使用float表示。所谓浮点型，指的就是小数。也叫作实数。</li><li>双精度浮点型：使用double表示。双精度浮点型表示的数据范围要比单精度浮点型要大。<br><code>即便double类型的值处于float类型的范围内也是不可以的。总之，能否成功赋值取决于等号右边的值的类型与等号左边的值的类型是否一致。</code><br><strong>问：如何将double类型转换为float类型的变量？<br>答: 强制转换，强制转换的语法是：类型 变量名 &#x3D; （类型）变量值</strong></li></ol><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        /*第一种方法*/        float a =(float) 1.2;//强制转换        System.out.println(a);        /*第二种方法*/        float a =1.2f;//强制转换        System.out.println(a);    &#125;&#125;</code></pre><ol start="7"><li>字符型：使用char表示（char是character的缩写）。所谓的字符，就是单个的字符表示，比如字母a,或中文张，外面用单引号包围上，比如char a &#x3D; ‘b’; char b &#x3D; ‘张’；</li></ol><pre><code class="java">public class Text&#123;    public static void main(String[] args)&#123;        char a = &#39;b&#39;;        System.out.println(a);    &#125;&#125;</code></pre><ol start="8"><li>布尔类型，使用boolean表示。布尔类型只有两种可能值，分别是true或者是flase。</li></ol><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        boolean  a = flase;        System.out,println(a);    &#125;&#125;</code></pre><p><code>可以将表示范围小的值赋给表示范围大的变量，但直接不能将表示范围大的值赋给表示范围小的变量，只能通过强制类型转换实现。</code><br>​</p><h1 id="第三讲"><a href="#第三讲" class="headerlink" title="第三讲"></a>第三讲</h1><ol><li>java中所有浮点类型默认情况下都是double。不能将double类型的值赋给float类型的变量，即便该double类型的值处于float类型的范围内也是不可以的。总之，能否成功赋值取决于等号右边的值的类型与等号左边的变量类型是否一致</li><li><strong>如何将double类型的值赋给float类型的变量？</strong><br>强制类型转换，将double类型的值强制转换为float类型<br><strong>强制转换的语法：类型 变量名 &#x3D; （类型） 变量值</strong></li><li>变量在使用前必须要赋值；变量必须要声明其类型方可使用；变量在使用前必须要定义，并且只能定义一次。</li></ol><h1 id="第四讲"><a href="#第四讲" class="headerlink" title="第四讲"></a>第四讲</h1><ol><li>当有若干个变量参与运算时，结果类型取决于这些变量中表示范围最大的那个变量类型。</li></ol><p>比如：参与运算的变量中，有整型 int ， 有双精度浮点型double，有短整型short，那么最后的结果类型就是double。</p><pre><code class="java">public class test&#123;    public static void main (String[] args)&#123;        int a = 1;        int b = 2;                int c = a + b;//3        int d = a - b;//-1        int e = a/b;//0        int f = a*b;//2        System.out.println(c);         System.out.println(d);         System.out.println(e);         System.out.println(f);     &#125;&#125;</code></pre><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        double a = 1;//出现double都让路        int b = 2;        double c = a + b;        double d = a - b;        double e = a/b;        double f = a*b;        System.out.println(c);        System.out.println(d);        System.out.println(e);        System.out.println(f);    &#125;&#125;</code></pre><p>下面的代码中，a 和 b 都是整型，但是通过（double）a这种转换将a转换为一个匿名的变量，该变量的类型是double，但是要注意：a本身依旧是int类型，而不是double类型，这样。(double)a&#x2F;b就是double类型除以int类型，结果自然是double类型。</p><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        int a = 1;        int b = 2;        double e = (double) a/b;        System.out.println(e);    &#125;&#125;</code></pre><p>取模运算符：使用%表示。【取模的规律：取模的结果符号永远与被除数的符号相同】</p><pre><code class="java">public class text&#123;   public static void main (String[] args)&#123;       int a = 5;       int b = 3;       int c = a % b;       System.out.println (c);   &#125;&#125;</code></pre><h1 id="第五讲"><a href="#第五讲" class="headerlink" title="第五讲"></a>第五讲</h1><ol><li>关系运算符：大于（&gt;），小于（&lt;），等于（&#x3D;&#x3D;）， 不等于（!&#x3D;），大于等于（&gt;&#x3D;）,小于等于（&lt;&#x3D;），关系运算的结果是个boolean值。</li></ol><pre><code class="java">public class text&#123;    public static void main (String[] args)&#123;        int a = 3 ;        int b = 2 ;        boolean c = ( a&gt;b );        System.out.println(c);    &#125;&#125;/*结果显示（true）*/</code></pre><p>2.逻辑运算符：重点讲解两个，逻辑运算符本身也返回一个boolean值。</p><p>1）逻辑与：使用&amp;&amp;表示，逻辑与是个双目运算符（即有两个操作数的运算符），只有当两个操作数都为真的时候，结果才为真；其余均为假。（逻辑与表示的并且的意思）</p><pre><code class="java">public class test &#123;    public static void main (String[] args)&#123;        int a = 1;        int b = 2;        int c = 3;        int d = 4;                boolean e = (a &lt; b) &amp;&amp; (c &lt; d);        System.out.println(e);    &#125;&#125;/*结果显示：true*/</code></pre><p>2）逻辑或：使用||表示，逻辑或也是个双目运算符，只有当两个操作数都为假的时候，结果才为假；其余情况都为真。（逻辑或表示或者的意思）</p><pre><code class="java">public static void main(String[] args)&#123;        int a = 1;        int b = 2;        int c = 3;        int d = 4;        boolean e = (a&lt;b)||(c&lt;d);        System.out.println(e);    &#125;&#125;/*结果显示：true*/</code></pre><p>3）关于逻辑运算符的短路特性。</p><ol><li><p>逻辑与：如果第一个操作数为flase，那么结果肯定就是flase，所以在这种情况下，，将不会执行后面的运算了，即发现了短路现象。</p></li><li><p>逻辑或：如果第一个操作数为true，那么结果肯定就是true，所在在这种情况下，将不会执行逻辑或后面的运算了，即发生了短路现象</p></li></ol><pre><code class="java">public class test &#123;    public static void main (String[] args)&#123;        int a = 1;        int b = 2;        int c = 3;        int d = 4;        int f = 5;        boolean e = (a &gt; b)||((f = c) &lt; d);        System.out.println(e);         System.out.println(f);   &#125;&#125;/* 结果是：true          5*/</code></pre><p>4）关于变量的自增与自减运算<br>1.关于 int b &#x3D; a++,作用是将a的值先赋给b，然后再让a自增1。<br>2.关于 int b &#x3D; ++a,作用是将a的值先自增1，然后将自增后的结果赋给b。</p><pre><code class="java">public class test &#123;    public static void main (String [] args)&#123;        int a = 3;        //a += 1;//等价于 a = a + 1;        a++;                System.out.println(a);    &#125;&#125;/*结果是：4*/</code></pre><pre><code class="java">public class test &#123;    public static void main (String [] args)&#123;        int a = 3;        //a += 1;//等价于 a = a + 1;        ++a;                System.out.println(a);    &#125;&#125;/*结果是：4</code></pre><pre><code class="java">public class test &#123;    public static void main (String [] args)&#123;        int a = 3;        //a += 1;//等价于 a = a + 1;        a--;                System.out.println(a);    &#125;&#125;/*结果是：2*/</code></pre><pre><code class="java">public class test &#123;    public static void main (String [] args)&#123;        int a = 3;        //a += 1;//等价于 a = a + 1;        --a;                System.out.println(a);    &#125;&#125;/*结果是：2*/</code></pre><h1 id="第七讲"><a href="#第七讲" class="headerlink" title="第七讲"></a>第七讲</h1><ol><li>java中的循环控制语句一共有三种，分别是while，do…while以及for循环。<br>1）while循环，形式为：</li></ol><pre><code class="Java">while (布尔表达式)&#123;    //待执行的代码&#125;</code></pre><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        int a = 1;//循环变量        int sum = 0;//存储相加后的变量                while(a &lt;= 100)&#123;            sum += a;            a++;76    &#125;&#125;/*结果是：5050*/</code></pre><p>​                 2）do……while循环，形式为：</p><pre><code class="Java">do&#123;    //待执行的代码&#125;while(布尔表达式);</code></pre><pre><code class="java">public class test &#123;    public static void main (String[] args)&#123;        int a = 1;        int sum = 0;        do&#123;            sum += a;            a++;        &#125;while(a&lt;=100);        System.out.println(sum);    &#125;&#125;/*结果是：5050*/</code></pre><p>while与do……while之间的区别：如果布尔表达式的第一次判断就为false，那么while循环一次也不执行；do…….while循环则会执行一次。如果布尔表达式第一次判断为true，那么while循环与do…….while循环等价。<br>3）for循环（使用最多的一种循环），形式为：</p><pre><code class="Java">for(变量初始化；条件判断；步进)&#123;   //待执行的代码&#125;</code></pre><p>for循环的执行过程：<br>1）执行变量初始化。<br>2）执行条件判断。如果条件判断结果为假，那么退出for循环，开始执行循环后面的代码；如果条件判断为真，执行for循环里面的代码。<br>3）执行步进。<br>4）重复步骤2。</p><pre><code class="java">public class test&#123;    public static void main (String[] args)&#123;        int sum = 0;//存储相加后的结果        for(int i = 1; i &lt;= 100;i++)&#123;            sum += i;        &#125;        System.out.println(sum);    &#125; &#125;</code></pre><h1 id="第八讲"><a href="#第八讲" class="headerlink" title="第八讲"></a>第八讲</h1><p><strong>理想面对程序对象</strong></p><ol><li>break语句：经常用在循环语句中，用于跳出整个循环，执行循环后面的代码。</li></ol><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        for(int i = 0;i &lt; 10 ; i++)&#123;            if(5 == i)&#123;                break;            &#125;            System.out.println(i);        &#125;    &#125;&#125;/*结果是：01234*/</code></pre><p>2.continue语句：经常用在循环语句中，用于跳出当前的这个循环（或者是跳出本次循环），开始下一次循环的执行。</p><pre><code class="java">public class Text&#123;    public static void main (String[] args)&#123;        for(int i = 0;i &lt; 10 ; i++)&#123;            if(5 == i)&#123;                continue;            &#125;            System.out.println(i);        &#125;    &#125;&#125;/*结果是：012346789*/</code></pre><p>3.break与continue可以搭配标签使用，在实际开发中，根本没有人会将break与continue搭配标签来使用。</p><pre><code class="java">public class Text&#123;    public static void main (St  ring[] args)&#123;        for(int i = 0;i &lt; 3; i++)&#123;            if(1 == i)&#123;                break;            &#125;            for (int j = 0 ; j &lt;= i; ++j)&#123;                if(1 == j)&#123;                    continue;                &#125;                System.out.println(&quot;j=&quot;+j);            &#125;            System.out.println(&quot;i=&quot;+i);        &#125;    &#125;&#125;/*结果是：j=0i=0*/</code></pre><p>4.面向对象程序设计（object oriented programming;oop）<br>1)什么是面向对象？<br>在面向对象程序设计中有两个重要的概念：类（class）与对象（object）。<br>2）类<br>类是一种抽象概念，类包含了数据（通常使用名词来表示）与对数据的操纵（通常使用动词来表示）。比如说人就是一种抽象的概念，人具有姓名、年龄、身高等数据，还有吃饭、跑步等操纵数据的动作。<br><strong>类包含两个内容</strong></p><pre><code>a）数据，数据在类中称作属性（Property或者attribute）或者叫成员变量（Member variable）b)对数据的操纵，这种操纵再类中称作方法（method）</code></pre><p>3）对象<br>对象是一种具体的概念，是类的一种具体的表现形式。比如说人是一种类，而张三、李四、王五等具体的人就是对象。</p><h1 id="第九讲"><a href="#第九讲" class="headerlink" title="第九讲"></a>第九讲</h1><ol><li><p>面向对象程序设计的三大基本特征：继承（inheritence）、封装（Encapsulation）、多态（Polymporphism）。</p></li><li><p>封装：类包含了数据与方法，将数据与方法放在一个类中就构成了封装。</p></li><li><p>如何定义类？</p><pre><code class="java">修饰符  class 类的名字&#123;       //类的内容(包含了属性与方法)   &#125;</code></pre></li><li><p>方法：如何定义方法？</p><pre><code>修饰符 返回类型  方法名称([参数一，参数二，参数三])&#123;   //方法体&#125;</code></pre></li><li><p>Main方法是整个JAVA程序的入口点，如果类的定义中没有main方法则程序无法执行。</p><pre><code>class Text&#123;    //两个整数相加    public int  add(int a,int b)&#123;        return a + b;    &#125;    //两个整数相-    public int  subtract(int a,int b)&#123;        return a - b;    &#125;    //两个整数相乘    public int  multiply(int a,int b)&#123;        return a * b;    &#125;    //两个整数相除    public int  divide(int a,int b)&#123;        return a / b;    &#125;&#125;</code></pre></li><li><p>方法定义不能嵌套，也就是说不能在一个方法中定义另外一个方法，方法只能定义在类中。</p></li><li><p>关于方法的执行，首先需要定义方法，接下来就可以使用方法（调用方法），当方法调用完毕后，方法可以返回值，方法到底是否返回值是由方法的定义决定的。</p></li><li><p>如何生成对象？通过类来生成对象（通常使用new关键字来生成对象）。</p></li></ol><pre><code>public class Person&#123;    &#125;类名    变量名    = new 类名；Person persion1 = new persion();new之后才是对象</code></pre><ol start="9"><li><p>方法调用需要通过对象来完成。方法调用的形式：</p><p>对象变量.方法名([参数值一，参数值二，参数值三……])</p></li></ol><pre><code class="java">   class Text&#123;       //两个整数相加       public int  add(int a,int b)&#123;           return a + b;       &#125;       //两个整数相-       public int  subtract(int a,int b)&#123;           return a - b;       &#125;       //两个整数相乘       public int  multiply(int a,int b)&#123;           return a * b;       &#125;       //两个整数相除       public int  divide(int a,int b)&#123;           return a / b;       &#125;              public static void main (String[] args)&#123;           Text text = new Text();           int x = 6;           int y = 1;           int a = text.add(x,y);           System.out.println(a);       &#125;   &#125; </code></pre><ol start="10"><li><p>关于方法的注意事项:</p><ol><li>在方法定义中，方法的返回类型与return后面的变量或常量类型保持一致。</li><li>在方法调用时，给方法传递的参数需要与方法定义时的参数保持一致（参数个数保持一致，参数类型保持一致）。</li><li>方法定义时的返回类型与接收方法返回值的变量类型保持一致。</li></ol></li><li><pre><code>public int add (int a,int b)&#123;    return a + b;&#125;方法定义时的参数叫做形式参数。int a = text.add(1,1);方法调用时所赋予的具体值叫做实际参数。</code></pre></li><li><p>关键字void 表示方法不返回值</p><pre><code class="java">class Text&#123;    //使用void。关键字表示方法不返回值    public void  output()&#123;        System.out.println(&quot;Hello world&quot;);    &#125;    public static void main (String[] args)&#123;        Text text = new Text();        text.output();    &#125;&#125;</code></pre></li><li><p>如果方法不返回值，那么声明方法的时候使用void关键字。在方法定义中，可以有两种情况实现不返回值：</p><p>a) 不使用return语句。</p><p>b）使用return。但return后面没有任何值或者变量，return后面只有一个分号，表示退出方法，返回到方法调用端。<code>return；</code></p></li></ol><h1 id="第十讲"><a href="#第十讲" class="headerlink" title="第十讲"></a>第十讲</h1><ol><li><p>类中的属性又叫做成员变量（member variable），属性用英文表示为property或者attribute。</p></li><li><p>对象（Object）又叫做实例。生成一个对象的过程又叫做实例化。</p></li><li><p>命名约定</p><p>a) 类：首字母大写，如果一个类名有多个单词构成，那么每个单词的首字母都大写，          中间不使用任何的连接符。比如：Person类，MemberTest类。</p><p>b)方法：首字母小写。如果一个方法由多个单词构成，那么第一个单词的所有字母全都小写，从第二个单词开始，每个单词的首字母大写。比如add，addThreeInt。</p><p>c）属性：命名约定与方法相同。比如age，ageOfPerson。</p></li><li><p>属性需要定义在类中，又叫做成员变量；而定义在方法中的变量叫做局部变量。</p></li><li><p>如何定义属性？</p><pre><code class="java">public class Persion&#123;    修饰符  类型  属性名称；&#125;</code></pre></li><li><p>如何使用属性？与方法一样，使用“.”运算符。首先需要生成类的实例，然后使用实例+“.”到方式来使用属性。</p><pre><code class="哦">Person person = new person();person.age</code></pre><pre><code class="java">public class Persion&#123;    int age = 20 ;    public static void main (String[] args)&#123;        Persion persion = new Persion();        System.out.println(Persion.age);    &#125;&#125;</code></pre></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/a20a89011c95476ff2d72c46473e6dfb.png" alt="在这里插入图片描述"></p><ol start="7"><li><p>局部变量使用前必须要声明并赋初值；中原变量使用前必须要声明，但可以不赋初值。</p></li><li><p>成员变量与局部变量的联系与区别：</p><p>a）没有，无论是成员变量还是局部变量，使用前都需要声明嗯或定义。</p><p>b）对于局部变量来说，使用前必须要初始化；对于成员变量来说，使用前可以不初始化。如果没有初始 化成员变量就开始使用，那么每个类型的成员变量都有一个默认的初始值。</p><p>​    i. byte、short、int、long类型的初始值为0</p><p>​    ii. float、double类型的初始值为0.0</p><p>​    iii. char类型的初始值为“\u0000”</p><p>​    iiii. boolean类型的初始值为false</p></li><li><p>引用类型（reference type），引用类型是用在对象上的。一个对象可以被多个引用所指向，但同一时刻，每个引用只能指向唯一的一个对象。如果一个对象被多个引用所指向，那么无论哪个引用对对象的属性进行了修改，都会反应到其他的引用当中。</p><pre><code class="java">class One &#123;    int age = 20;    public void change(One one)&#123;        one.age = 30;    &#125;    public static void main (String[] args)&#123;        One one = new One();        int age = one.age;        System.out.println(age);        one.change(one);        int age2 = one.age;        System.out.println(age2);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/8f8d6de84058f2afe2dddd51b6ce02d9.png"></p></li></ol><h1 id="第十一讲"><a href="#第十一讲" class="headerlink" title="第十一讲"></a>第十一讲</h1><ol><li><p>如果一个类包含了属性与方法，那么该类的每个对象都具有自己的属性，但无论一个类有多少对象，这些对象共享同一个方法。</p></li><li><p>关于方法参数传递的总结：对于JAVA中的方法参数传递，无论传递的是原生数据类型还是引用类型，统一是传值。</p><pre><code class="Java">public class ParamText&#123;    public static void main (String[] args)&#123;        Person person = new Person();        person.change(person);        int age = persion.age;        System.out.println(age);        System.out.println(&quot;-------&quot;);        int i = 10;        person.change1(i);        System.out.println(i);    &#125;&#125;class Person&#123;    int age = 20 ;    public void change(Person person)&#123;        person.age = 30 ;    &#125;    public void change1(int age)&#123;        age = 40;    &#125;&#125;</code></pre><ol start="3"><li><p>什么类型的引用就能指下什么类型的对象，比如People类型的引用就能指向People类型的对象，但不能指向student类型的对象。比如:</p><p>People people &#x3D; new People();&#x2F;&#x2F;正确</p><p>People people &#x3D; new Student();&#x2F;&#x2F;错误</p></li></ol></li><li><p>构造方法（Constructor）：构造方法用于完成对象属性的初始化工作。构造方法的特点：</p><ol><li>构造方法的名字必须与类名完全一致（包括大小写）。</li><li>构造方法没有返回值，连void也不能出现。</li><li>如果在定义一个类的时候，没有喂类声明构造方法。那么JAVA编译器会自动为类添加一个没有参数且方法体为空的构造方法（默认的构造方法）。</li><li>如果在定义一个类的时候为类声明了构造方法，那么JAVA编译器就不会再被类添加构造方法了。</li><li>不能显示调用类的构造方法，构造方法通常是通过new关键字隐式调用。</li></ol></li><li><p>New关键字在生成对象时完成了三件事情：</p><ol><li>为对象开辟内存空间</li><li>调用类的构造方法</li><li>将生成的对象地址返回（返回给引用）</li></ol></li><li><p>默认的构造方法：构造方法没有参数，且方法体为空。</p></li><li><p>使用new来生成对象的时候，后面的小括号（）表示构造方法的参数列表，如果构造方法不接受参数，那么小括号中的内容为空；如果构造方法接收参数，那么小括号中的实际参数就要与构造方法定义中的形式参数保持一致（参数的数量一致、参数的类型一致、按照顺序逐一的赋值）。</p></li></ol><h1 id="第十二讲"><a href="#第十二讲" class="headerlink" title="第十二讲"></a>第十二讲</h1><ol><li><p>注释：注释是给人看的，不是给计算机看的。JAVA中共有三种类型的注释：</p><ol><li>单行注释：以&#x2F;&#x2F;开头，&#x2F;&#x2F;后面的所有内容均被当作注释做注释处理。</li><li>多行注释：以&#x2F;<em>开头，以</em>&#x2F;结束，中间的所有内容均被当做注释处理，多行注释来源于c&#x2F;c++。关于多行注释，需要注意的是，多行注释不能嵌套。</li><li>另一种多行注释用于产生JAVA doc帮助文档。</li></ol></li><li><p>强制类型转换</p><p>float f &#x3D; 1.2f;</p><p>float f &#x3D; (float)1.2;</p><pre><code class="java">public class FlaotText&#123;    public static void main(String[] args)&#123;        flaot f = 1.2f;        System.out.println(f);    &#125;&#125;</code></pre></li><li><p>轻量级文本编译器：vi,vim,gvim,UItraEdit,Editplus</p></li><li><p>类是一种抽象的概念，对象是类的一种具体表示形式，是具体的概念。先有类，然后由类来生成对象，对象又叫做实例。</p></li><li><p>类有两大部分构成：属性以及方法，属性一般用名词来表示，方法一般用动词来表示。  </p></li><li><p>如果有一个JAVA源文件中定义了多个类，那么这些类最多只能有一个类是pub换句话说定义的多个类可以都不是public的。</p></li><li><p>在JAVA中进行方法的参数传递时，无论传递的是原生数据类型还是引用类型，参数传递方式统一是传值，JAVA中没有传引用的概念。</p><p><strong>第十二讲到第十六讲都为复习！！！</strong></p></li></ol><h1 id="第十七讲"><a href="#第十七讲" class="headerlink" title="第十七讲"></a>第十七讲</h1><ol><li><p>方法重载（Overload）：表示两个或多个方法名字相同，但方法参数不同。方法参数不同有两层含义：1. 参数个数不同。2. 参数类型不同。注意：方法的返回值对重载没有任何影响。</p><pre><code class="java">public class Teat&#123;    public int add (int a,int b)&#123;        return a + b;    &#125;        public int add (int a,int b,int c)&#123;        return a + b + c;    &#125;        public static void main (String[] args)&#123;        Teat test = new Teat();        int result = test.add(1+2);        int result2 = test.add(1+2+3);        System.out.println(result);        System.out.println(result2);    &#125;&#125;</code></pre></li><li><p>构造方法重载：只需要看参数即可。如果想在一个构造方法中调用另外一个构造方法，那么可以使用this()的方式调用，this()括号中的参数表示目标构造方法的参数。this()必须要作为构造方法的第一条语句，换句话说，this()之前不能有任何可执行的代码。</p><pre><code class="java">public class One&#123;    public One()&#123;        Systerm.out.println(&quot;test&quot;);    &#125;    public One(int i)&#123;        System.out.println(++i);    &#125;    public static void mian (String[] args)&#123;        One co = new One();    &#125;&#125;</code></pre></li><li><p>继承（inheritance）：Java是单继承的，意味着一个类只能从另一个类继承（被继承的类叫做父类【基类，base class】,继承的类叫做子类），Java中的继承使用extends关键字。</p><pre><code class="java">public class Child extents Parent&#123;    public Child()&#123;        System.out.println(&quot;child&quot;);    &#125;    public static void main (String[] args)&#123;        Child child = new Child();    &#125; &#125;class Parent&#123;    public Parent()&#123;        System.out.println(&quot;parent&quot;);    &#125;&#125;</code></pre></li><li><p>当生成子类对象时，JAVA默认首先调用父类的不带参数的构造方法。然后执行该构造方法生成父类的对象，接下来再去调用子类的构造方法，生成子类的对象。【要想生成子类的对象，首先需要生成父类的对象，没有父类对象就没有子类对象，比如说没有父亲就没有孩子。】</p></li></ol><pre><code class="java">public class Child extents Parent&#123;    public Child()&#123;        super(1);//调用父类特定的构造方法        System.out.println(&quot;child&quot;);    &#125;    public static void main (String[] args)&#123;        Child child = new Child();    &#125; &#125;class Parent&#123;    public Parent(int i)&#123;        System.out.println(&quot;parent&quot;);    &#125;&#125;</code></pre><ol start="5"><li><p>super关键字：super表示对父类对象的引用。</p></li><li><p>如果子类使用super（）显示调用父类的某个构造方法，那么在执行的时候就会寻找与super（）所对应的构造方法而不会再去寻找父类的不带参数的构造方法。与this一样，super也必须要作为构造方法的第一条执行语句。前面不能有其他可执行的语句。</p></li><li><p>关于继承有以下几点：</p><ol><li>父类有的，子类也有。</li><li>父类没有的，子类可以增加。</li><li>父类有的，子类可以改变。</li></ol></li><li><p>关于继承的注意事项</p><ol><li>构造方法不能被继承。</li><li>方法和属性可以被继承。</li><li>子类的构造方法隐式的调用父类的不带参数的构造方法。</li><li>当弗雷没有不带参数的构造方法时，子类需要使用super来显示的调用父类的构造方法，super指的是对父类的引用。</li><li>super关键字必须是构造方法中的第一行语句。</li></ol></li></ol><h1 id="第十八讲"><a href="#第十八讲" class="headerlink" title="第十八讲"></a>第十八讲</h1><ol><li><p>方法重写（Override）又叫做覆写：子类与父类的方法返回类型一样，方法名称一样，参数一样，这样我们说此类与父类的方法构成了重写关系。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Dog dog = new Dog();        dog.run();    &#125;&#125;class Animal &#123;    public void run()&#123;        System.out.println(&quot;animal is runing&quot;);    &#125;&#125;class Dog extends Animal&#123;&#125;</code></pre></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/8c495e753639097f8771eaa01da57421.png" alt="在这里插入图片描述"></p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Dog dog = new Dog();        dog.run();    &#125;&#125;class Animal &#123;    public void run()&#123;        System.out.println(&quot;animal is runing&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void run()&#123;        System.out.println(&quot;dog is running&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/78d5a7d72e9e00011da4858208a45964.png" alt="在这里插入图片描述"></p><ol start="2"><li>方法重写与方法重载之间的关系：重载发生在同一个类内部的两个或多个方法。重写发生在父类与子类之间。</li></ol><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Dog dog = new Dog();        dog.run(1);    &#125;&#125;class Animal &#123;    public void run()&#123;        System.out.println(&quot;animal is runing&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void run(int i)&#123;        super.run();//调用父类的代码        System.out.println(&quot;dog is running&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/b1375f7461a17e9830e21865d778dae9.png" alt="在这里插入图片描述"><br>3. 当两个方法形成重写关系时，可以在子类方法中通过super.run()形式调用父类的run()方法，其中super.run（）形式调用父类的run（）方法，其中super.run()不必放在第一行语句，因此此时父类对象已经构造完毕，先调用父类的run()方法是根据程序的逻辑决定的。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Dog dog = new Dog();        dog.run(1);    &#125;&#125;class Animal &#123;    public void run()&#123;        System.out.println(&quot;animal is runing&quot;);    &#125;&#125;class Dog extends Animal&#123;    public void run(int i)&#123;        System.out.println(&quot;dog is running&quot;);        super.run();//调用父类的代码    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/2fdf05257e0394199ed14e5e53441fd4.png" alt="在这里插入图片描述"><br>4. 在定义一个类的时候，如果没有显试指定该类的父类，那么该类就会继承于java.lang.Object类（JDK提供的一个类，Object类是JAVA中所有类的直接或间接的父类）。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Son son = new Son();    &#125;&#125;class Grandpa&#123;    public Grandpa()&#123;        System.out.println(&quot;Grandpa&quot;);    &#125;&#125;class Father extends Grandpa&#123;    public Father()&#123;        System.out.println(&quot;father&quot;);    &#125;&#125;class Son extends  Father&#123;    public Son()&#123;        System.out.println(&quot;son&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/a9ecc90105adf78cfbae83670a321ad2.png" alt="在这里插入图片描述"><br>5. 多态（Polymorphism）:我们说子类就是父类（玫瑰花是花，男人是人），因此多态的意思就是：父类型的引用可以指向子类对象。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Flower rose = new Rose();//多态        rose.sing();    &#125;&#125;class Flower&#123;    public void sing()&#123;        System.out.println(&quot;it is singing&quot;);    &#125;&#125;class Rose extends Flower&#123;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/68b9e1fcd3d88e7dfe2c4ef98d1718db.png" alt="在这里插入图片描述"></p><h1 id="第十九讲"><a href="#第十九讲" class="headerlink" title="第十九讲"></a>第十九讲</h1><ol><li><p>多态：父类型的引用可以指向子类型的对象。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Parent child = new Child();        child.sing();    &#125;&#125;class Parent&#123;    public void sing()&#123;        System.out.println(&quot;parent is singing&quot;);    &#125;&#125;class Child extends Parent&#123;    public void sing()&#123;        System.out.println(&quot;child is singing&quot;);    &#125;&#125;</code></pre></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/5249c825efda6ea8785e9c64ed44d195.png" alt="在这里插入图片描述"><br>2. Parent child &#x3D; new Child();当使用多态方式调用方法时，首先检查父类是否有sing()方法，如果没有编译错误；如果有，再去调用子类的sing()方法。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Animal a = new Dog();        Dog dog =  (Dog)a;        dog.sing();    &#125;&#125;class Animal &#123;    public void sing ()&#123;        System.out.println(&quot;animal is singing&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void sing()&#123;        System.out.println(&quot;Dog is singing&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/cef768f4cc2989d6ea1ef09f544b5ecd.png" alt="在这里插入图片描述"></p><h1 id="第二十讲"><a href="#第二十讲" class="headerlink" title="第二十讲"></a>第二十讲</h1><ol><li><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        Animal animal = new Dog();        Animal animal2 = new Animal();        animal2 = animal;        animal2.sing();    &#125;&#125;class Animal &#123;    public void sing ()&#123;        System.out.println(&quot;animal is singing&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void sing()&#123;        System.out.println(&quot;Dog is singing&quot;);    &#125;&#125;</code></pre></li></ol><p> <img src="https://img-blog.csdnimg.cn/img_convert/b565c18eb20d66b8cb7c3143ae316d61.png" alt="在这里插入图片描述"></p><ol start="2"><li><p>一共有两种类型的强制类型转换：</p><ol><li><p>向上的类型转换（upcast）：比如说将dog类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显示指定。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        //向上类型转换        Dog dog = new Dog();        Animal animal = dog;        animal.sing();    &#125;&#125;class Animal &#123;    public void sing ()&#123;        System.out.println(&quot;animal is singing&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void sing()&#123;        System.out.println(&quot;Dog is singing&quot;);    &#125;&#125;</code></pre></li></ol></li></ol><p><img src="https://img-blog.csdnimg.cn/img_convert/f1e0859993c496201dea07b53f6cf0a9.png" alt="在这里插入图片描述"></p><ol start="2"><li><p>向下的类型转换（downcast）：比如将Animal类型转换为dog类型。即将父类型转换为子类型。对于向下类型转换，必须要显示指定（必须要使用强制类型转换）。</p><pre><code class="java">package lianxi;public class Test2 &#123;    public static void main(String[] args)&#123;        //向下类型转换        Animal a = new Dog();        Dog dog = (Dog)a;        dog.sing();    &#125;&#125;class Animal &#123;    public void sing ()&#123;        System.out.println(&quot;animal is singing&quot;);    &#125;&#125;class Dog extends Animal &#123;    public void sing()&#123;        System.out.println(&quot;Dog is singing&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ef73b0a621ee3f1ec6fdd9f972c41d58.png" alt="在这里插入图片描述"></p></li></ol><h1 id="第二十一讲"><a href="#第二十一讲" class="headerlink" title="第二十一讲"></a>第二十一讲</h1><ol><li>抽象类（abstract class ）:使用abstract关键字所修饰的累叫做抽象类。抽象类无法实例化，也就是说，不能new出来一个抽象类的对象（实例）。<br><strong>错误演示</strong></li></ol><pre><code>package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;        T t = new T();    &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/0ba2a463cae44625beca1b9afafa9b63.png" alt="在这里插入图片描述"><br>2. 抽象方法（abstract method）:使用abstract关键字所修饰的方法叫做抽象方法。<em><strong>抽象方法需要定义在抽象类中。</strong></em> 相对于抽象方法，之前所定义的方法叫做具体方法（有声明，有实现）</p><pre><code class="java">package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;            &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;    public abstract void method();&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/013d0f601df69680f4398a812da479d1.png" alt="在这里插入图片描述"><br>3. 如果有一个类包含了抽象方法，那么这个类一定是个抽象类。<br>4. 如果某个类是抽象类，那么该类可以包含具体方法（有声明，有实现）。</p><pre><code class="java">package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;    &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;    public abstract void method();    public void test()&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/cb876ae8efe405321058cffed5c49c10.png" alt="在这里插入图片描述"><br>5. 如果一个类中包含了抽象方法，那么这个类一定要声明成abstract class ，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法。<br>6. 无论何种情况，只要一个类是抽象类，那么这个类就无法实例化。<br>7. 在子类继承父类（父类是一个抽象类）的情况下，那么该子类必须要实现父类中所定义的所有抽象方法；否则，该子类需要声明一个<strong>abstract class</strong> 。<br><em><strong>错误示范</strong></em></p><pre><code class="java">package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;        R r = new R();    &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;    public abstract void method();    public void test()&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;class R extends T&#123;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/a93c911ae8c2022d643d78864c959259.png" alt="在这里插入图片描述"><br><em><strong>正确示范</strong></em></p><pre><code class="java">package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;        R r = new R();    &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;    public abstract void method();    public void test()&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;class R extends T&#123;    public void method()&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/747f34187aa0b2a9bcc909411888b29e.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise001 &#123;    public static void main (String[] args)&#123;        //R r = new R();    &#125;&#125;//使用abstract关键字所修饰的累叫做抽象类。abstract class T&#123;    public abstract void method();    public void test()&#123;        System.out.println(&quot;test&quot;);    &#125;&#125;abstract class R extends T&#123;    &#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/b4f65a0359ffeb96f084ce1935e15436.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise002 &#123;    public static void main(String[] args)&#123;        Shape shape = new Triange(10,6);        int area = shape.computeArea();        System.out.println(area);        shape = new Rectangle(10,10);        int areas = shape.computeArea();        System.out.println(areas);    &#125;&#125;abstract class Shape&#123;    public abstract int computeArea();//计算形状面积&#125;class Triange extends Shape&#123;    int width;    int heights;    public Triange(int width,int heights)&#123;        this.width = width;//自己获取自己        this.heights= heights;    &#125;    public int computeArea()&#123;        return width * heights /2;    &#125;&#125;class Rectangle extends Shape&#123;    int width;    int heights;    public Rectangle(int width,int heights)&#123;        this.heights = heights;        this.width = width;    &#125;    public int computeArea()&#123;        return width * heights;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ae5233b528794ccbd8c73f25a68295cc.png" alt="在这里插入图片描述"></p><h1 id="第二十二讲"><a href="#第二十二讲" class="headerlink" title="第二十二讲"></a>第二十二讲</h1><ol><li>接口（interface）：接口的地位等同于class, <strong>接口中所有方法都是抽象方法。</strong> 在声明接口中的方法时，可以使用abstract关键字，也可以不使用。通常情况下，都会省略掉abstract关键字。（有声明，无实现）</li></ol><pre><code class="java">package exercise;public interface exercise003 &#123;    public void output();//抽象方法    public static void main(String[] args)&#123;    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/5118ed222df0b9bbb85623459b598e39.png" alt="在这里插入图片描述"><br>2. 可以将接口看作是特殊的抽象类（抽象类中可以有具体方法，也可以有抽象方法，而接口中只能有抽象方法，不能有具体方法）。<br>3. 类可以实现接口，实现使用关键字implements表示，代表了某个类实现了某个接口。</p><pre><code class="java">package exercise;public class exercise003 &#123;    public static void main (String[] args)&#123;        Myclass myclass = new Myclass();        myclass.output();    &#125;&#125;interface MyInterface&#123;    public void output();&#125;class Myclass implements MyInterface&#123;     public void output()&#123;         System.out.println(&quot;output&quot;);     &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/23442f953476d0038f76d743e853fdd6.png" alt="在这里插入图片描述"><br>4. 一个类实现了某个接口，那么该类必须要实现接口声明的所有方法。如果该类是个抽象类，那么就无需实现接口中的方法了。<br>5. Java是单继承的，也就是说某个类只能有唯一一个父类；一个类可以实现多个接口，多个接口之间使用逗号分隔。</p><pre><code class="java">package exercise;public class exercise003 &#123;    public static void main (String[] args)&#123;        Myclass myclass = new Myclass();        myclass.output();        myclass.output2();    &#125;&#125;interface MyInterface&#123;    public void output();&#125;interface MyInterface2&#123;    public void output2();&#125;class Myclass implements MyInterface,MyInterface2&#123;     public void output()&#123;         System.out.println(&quot;output&quot;);     &#125;    @Override    public void output2() &#123;        System.out.println(&quot;output2&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/5d3bc0fa9bcd9250798a0d26421fda2d.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise003 &#123;    public static void main (String[] args)&#123;        Myclass myclass = new Myclass();        myclass.output();        myclass.output2();        myclass.output3();    &#125;&#125;interface MyInterface&#123;    public void output();&#125;interface MyInterface2&#123;    public void output2();&#125;class Myparent&#123;    public void output3()&#123;        System.out.println(&quot;output3&quot;);    &#125;&#125;class Myclass extends Myparent implements MyInterface,MyInterface2&#123;     public void output()&#123;         System.out.println(&quot;output&quot;);     &#125;    @Override    public void output2() &#123;        System.out.println(&quot;output2&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/804ae2b6c3abd1be6dcf288f15d2515d.png" alt="在这里插入图片描述"><br>6. 多态：所谓多态，就是父类型的引用可以指向子类型的对象，或者接口类型的引用可以指向实现该接口的类的实例。关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样。</p><pre><code class="java">package exercise;public class exercise004 &#123;    public static void mian (String[] args)&#123;        AA bb = new BB();//多态        bb.output();    &#125;&#125;interface  AA&#123;    public void output();&#125;class BB implements AA&#123;    public void output()&#123;        System.out.println(&quot;BB&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/0583f6c352ca418a07059f12b099aec4.png" alt="在这里插入图片描述"><br>7. Static 关键字：可以用于修饰属性，也可以用于修饰方法，还可以用于修饰类。<br>8. static 修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也随之发生变化。如果一个成员变量是static的，那么我们可以通过 <strong>类名.成员变量名</strong> 的方式来使用它（Java推荐我们使用这种方法）。</p><pre><code class="java">package exercise;public class exercise005 &#123;    public static void main (String[] args)&#123;        MyStatic myStatic = new MyStatic();        MyStatic myStatic1 = new MyStatic();        myStatic.a = 10;        System.out.println(myStatic1.a);    &#125;&#125;class MyStatic&#123;    static int a;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/4f8a2631b9c7f2efa9b6d998e77f460f.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise005 &#123;    public static void main (String[] args)&#123;        MyStatic myStatic = new MyStatic();        myStatic.a = 10;        System.out.println(myStatic.a);    &#125;&#125;class MyStatic&#123;    static int a;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/88e715056d0a8694d3e63f47a992f031.png" alt="在这里插入图片描述"></p><h1 id="第二十三讲"><a href="#第二十三讲" class="headerlink" title="第二十三讲"></a>第二十三讲</h1><ol><li>static 修饰方法：static 修饰的方法叫做静态方法。对于静态方法来说，可以使用类名.方法名的方式来访问。<br><em><strong>正常</strong></em></li></ol><pre><code class="java">package exercise;public class exercise006 &#123;    public static void main (String[] args)&#123;        MyStatic2 test =new MyStatic2();        test.out();    &#125;&#125;class MyStatic2&#123;    public void out()&#123;        System.out.println(&quot;out&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ba1a7426af97fe8c6a4b40070d2b0b0f.png" alt="在这里插入图片描述"><br><em><strong>修正后的</strong></em></p><pre><code class="java">package exercise;public class exercise006 &#123;    public static void main (String[] args)&#123;        MyStatic2.out();    &#125;&#125;class MyStatic2&#123;    public static void out()&#123;        System.out.println(&quot;out&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/2068582e7d2b630b9576bac0f5da187e.png" alt="在这里插入图片描述"><br><em><strong>对比</strong></em></p><pre><code class="java">package exercise;public class exercise007 &#123;    public static void main (String[] args)&#123;        N n = new N();        n.output();    &#125;&#125;class M&#123;    public static void output()&#123;        System.out.println(&quot;m&quot;);    &#125;&#125;class N extends M&#123;    public static void output()&#123;        System.out.println(&quot;N&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/57725ce7ecc4fe5f12343e88e2327add.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise007 &#123;    public static void main (String[] args)&#123;        M m = new N();        m.output();    &#125;&#125;class M&#123;    public static void output()&#123;        System.out.println(&quot;m&quot;);    &#125;&#125;class N extends M&#123;    public static void output()&#123;        System.out.println(&quot;N&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/e25ecd246773734c82f3956a7be19256.png" alt="在这里插入图片描述"><br> <strong>2. 静态方法只能继承，不能重写（Override）。</strong><br> 3. final关键字：final可以修饰属性、方法、类。<br> 4. final修饰类：当一个类被final所修饰时，表示该类是一个终态类，即不能被继承。</p><pre><code class="java">package exercise;public class exercise008 &#123;    public static void main(String[] args)&#123;        F f = new F();    &#125;&#125;final class E&#123;//表示该类不能被继承&#125;class F extends E&#123;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/9d81b517f6cf9e69990d50d91e5cc85e.png" alt="在这里插入图片描述"><br>5. final修饰方法：当一个方法被final所修饰时，表示该方法是一个终态方法，即不能被重写（Override） 。<br><em><strong>错误示例</strong></em></p><pre><code class="java">package exercise;public class exercise008 &#123;    public static void main(String[] args)&#123;        H h =new H();        h.out();    &#125;&#125;class G&#123;    public final void out()&#123;        System.out.println(&quot;G&quot;);    &#125;&#125;class H extends G&#123;     public void out()&#123;        System.out.println(&quot;H&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/ea71f63ac4d55be2177316fdc52d1f2c.png" alt="在这里插入图片描述"><br>6. final 修饰属性：当一个属性被final所修饰时，表示该属性不能被改写。<br><em><strong>错误示例</strong></em></p><pre><code class="java">package exercise;public class exercise008 &#123;    public static void main(String[] args)&#123;        People people = new People();        people.age = 20;    &#125;&#125;class People&#123;    final int age =10;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/b75c0bc5fb0e868edf57233466dfa1d5.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise008 &#123;    public static void main(String[] args)&#123;        People people = new People();        people.address.name = &quot;shanghai&quot;;    &#125;&#125;class People&#123;    final Address address = new Address();&#125;class Address&#123;    String name = &quot;dalian&quot;;&#125;</code></pre><p><em><strong>可以执行</strong></em><br><img src="https://img-blog.csdnimg.cn/img_convert/128130f4bd43c029122fdf104133f055.png" alt="在这里插入图片描述"><br>7. 当final修饰一个原生数据类型时，表示该原生数据类型的值不能发生变化（比如说不能从10变成20）；如果final修饰一个引用类型时，表示该引用类型不能在指向其他对象了；但该引用所指向的对象的内容是可以发生变化的。</p><h1 id="第二十四讲"><a href="#第二十四讲" class="headerlink" title="第二十四讲"></a>第二十四讲</h1><ol><li>对于final类型成员变量，一般来说有两种赋初值方式：<ol><li>在声明final类型的成员变量时就赋上初值。</li></ol></li></ol><pre><code class="java">package exercise;public class exercise009 &#123;    final int a = 0;&#125;</code></pre><pre><code>2. 在声明final类型的成员变量时不赋初值，但在类的所有构造方法中都为其赋上初值。</code></pre><pre><code class="java">package exercise;public class exercise009 &#123;    final int a;    public exercise009()&#123;        a = 0;    &#125;    public exercise009(int a)&#123;        this.a = a;    &#125;&#125;</code></pre><ol start="2"><li>static 代码块：静态代码块。静态代码块的作用也是完成一些初始化工作。首先执行静态代码块，然后执行构造方法。静态代码块在类被加载的时候执行，而构造方法是在生成对象的时候执行；要想调用某个类来生成对象，首先需要将类加载到Java虚拟机上（JVM），然后由jvm加载这个类来生成对象。</li></ol><pre><code class="java">package exercise;public class exercise009 &#123;    public static void main (String[] args)&#123;        P p = new P();        P p2 = new P();    &#125;&#125;class P&#123;    static &#123;        System.out.println(&quot;static block&quot;);    &#125;    public P()&#123;        System.out.println(&quot;P out&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/5e41b2ad74c06493be930c575e7108aa.png" alt="在这里插入图片描述"></p><pre><code class="java">package exercise;public class exercise009 &#123;    public static void main (String[] args)&#123;        new S();    &#125;&#125;class P&#123;    static &#123;        System.out.println(&quot;P static block&quot;);    &#125;    public P()&#123;        System.out.println(&quot;P out&quot;);    &#125;&#125;class Q extends P&#123;    static &#123;        System.out.println(&quot;Q static&quot;);    &#125;    public Q()&#123;        System.out.println(&quot;Q out&quot;);    &#125;&#125;class S extends Q&#123;    static &#123;        System.out.println(&quot;S static&quot;);    &#125;    public S()&#123;        System.out.println(&quot;S out&quot;);    &#125;&#125;</code></pre><p><img src="https://img-blog.csdnimg.cn/img_convert/1ef8d1a7221639f784db5255f4ba35ff.png" alt="在这里插入图片描述"><br>3. 类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所有静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以new一次就会调用构造方法一次。<br>4. 如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类的静态代码块，一直执行到最底层类的静态代码块。<strong>注意：静态代码块只会执行一次</strong> 。<br>5. 不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态的成员变量。可以在非静态方法中访问静态的成员变量。</p><pre><code class="java">package exercise;public class exercise010 &#123;    public static void main (String[] args)&#123;        W.change();    &#125;&#125;class W &#123;    static int a = 10;    public static void change()&#123;        a++;    &#125;&#125;</code></pre><ol start="6"><li><p><strong>总结：静态的只能访问静态的；非静态的可以访问一切</strong></p></li><li><p><strong>不能在静态方法中使用this关键字。</strong></p></li><li><p>多态：父类型的引用可以指向子类型的对象。</p></li><li><p>Parent child &#x3D; new Child();当使用多态方式调用方法时，首先检查父类是否有sing()方法，如果没有编译错误；如果有，再去调用子类的sing()方法。</p></li><li><p>一共有两种类型的强制类型转换：</p><ol><li>向上的类型转换（upcast）：比如说将dog类型转换为Animal类型，即将子类型转换为父类型。对于向上类型转换，不需要显示指定。</li><li>向下的类型转换（downcast）：比如将Animal类型转换为dog类型。即将父类型转换为子类型。对于向下类型转换，必须要显示指定（必须要使用强制类型转换）。</li></ol></li><li><p>抽象类（abstract class ）:使用abstract关键字所修饰的累叫做抽象类。抽象类无法实例化，也就是说，不能new出来一个抽象类的对象（实例）。</p></li><li><p>抽象方法（abstract method）:使用abstract关键字所修饰的方法叫做抽象方法。<em><strong>抽象方法需要定义在抽象类中。</strong></em> 相对于抽象方法，之前所定义的方法叫做具体方法（有声明，有实现）。</p></li><li><p>如果有一个类包含了抽象方法，那么这个类一定是个抽象类。</p></li><li><p>如果某个类是抽象类，那么该类可以包含具体方法（有声明，有实现）。</p></li><li><p>如果一个类中包含了抽象方法，那么这个类一定要声明成abstract class ，也就是说，该类一定是抽象类；反之，如果某个类是抽象类，那么该类既可以包含抽象方法，也可以包含具体方法。</p></li><li><p>无论何种情况，只要一个类是抽象类，那么这个类就无法实例化。</p></li><li><p>在子类继承父类（父类是一个抽象类）的情况下，那么该子类必须要实现父类中所定义的所有抽象方法；否则，该子类需要声明一个<strong>abstract class</strong> 。</p></li><li><p>接口（interface）：接口的地位等同于class, <strong>接口中所有方法都是抽象方法。</strong> 在声明接口中的方法时，可以使用abstract关键字，也可以不使用。通常情况下，都会省略掉abstract关键字。（有声明，无实现）。</p></li><li><p>可以将接口看作是特殊的抽象类（抽象类中可以有具体方法，也可以有抽象方法，而接口中只能有抽象方法，不能有具体方法）。</p></li><li><p>类可以实现接口，实现使用关键字implements表示，代表了某个类实现了某个接口。</p></li><li><p>一个类实现了某个接口，那么该类必须要实现接口声明的所有方法。如果该类是个抽象类，那么就无需实现接口中的方法了。</p></li><li><p>Java是单继承的，也就是说某个类只能有唯一一个父类；一个类可以实现多个接口，多个接口之间使用逗号分隔。</p></li><li><p>多态：所谓多态，就是父类型的引用可以指向子类型的对象，或者接口类型的引用可以指向实现该接口的类的实例。关于接口与实现接口的类之间的强制类型转换方式与父类和子类之间的强制类型转换方式完全一样。</p></li><li><p>Static 关键字：可以用于修饰属性，也可以用于修饰方法，还可以用于修饰类。</p></li><li><p>static 修饰属性：无论一个类生成了多少个对象，所有这些对象共同使用唯一一份静态成员变量；一个对象对该静态成员变量进行了修改，其他对象的该静态成员变量的值也随之发生变化。如果一个成员变量是static的，那么我们可以通过 类名.成员变量名 的方式来使用它（Java推荐我们使用这种方法）。</p></li><li><p>static 修饰方法：static 修饰的方法叫做静态方法。对于静态方法来说，可以使用类名.方法名的方式来访问。</p></li><li><p><strong>静态方法只能继承，不能重写（Override）。</strong></p></li><li><p>final关键字：final可以修饰属性、方法、类。</p></li><li><p>final修饰类：当一个类被final所修饰时，表示该类是一个终态类，即不能被继承。</p></li><li><p>final修饰方法：当一个方法被final所修饰时，表示该方法是一个终态方法，即不能被重写（Override） 。</p></li><li><p>final 修饰属性：当一个属性被final所修饰时，表示该属性不能被改写。</p></li><li><p>当final修饰一个原生数据类型时，表示该原生数据类型的值不能发生变化（比如说不能从10变成20）；如果final修饰一个引用类型时，表示该引用类型不能在指向其他对象了；但该引用所指向的对象的内容是可以发生变化的。</p></li><li><p>类的静态代码块只会执行一次，是在类被加载的时候执行的，因为每个类只会被加载一次，所有静态代码块也只会被执行一次；而构造方法则不然，每次生成一个对象的时候都会调用类的构造方法，所以new一次就会调用构造方法一次。</p></li><li><p>如果继承体系中既有构造方法，又有静态代码块，那么首先执行最顶层的类的静态代码块，一直执行到最底层类的静态代码块。<strong>注意：静态代码块只会执行一次</strong> 。</p></li><li><p>不能在静态方法中访问非静态成员变量；可以在静态方法中访问静态的成员变量。可以在非静态方法中访问静态的成员变量。</p></li><li><p><strong>总结：静态的只能访问静态的；非静态的可以访问一切</strong></p></li><li><p><strong>不能在静态方法中使用this关键字。</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring基础学习</title>
      <link href="/2023/08/18/Spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2023/08/18/Spring%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="SpringFamilyBase"><a href="#SpringFamilyBase" class="headerlink" title="SpringFamilyBase"></a>SpringFamilyBase</h1><p>本人学习spring全家桶的所有练习代码及笔记</p><p>（注解：spring2.5与Java1.8版本不兼容）！！！！！！</p><hr><h2 id="IOC控制反转"><a href="#IOC控制反转" class="headerlink" title="IOC控制反转"></a>IOC控制反转</h2><p>在applicationContext.xml中编写的是</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd&quot;&gt;    &lt;!--        bean:将某一各类交给spring容器来管理，那么这个类就是一个bean里            id：为指定的bean类获取一个唯一的标识符            class： 指定bean类的包路径        bean对象：通过spring容器创建的对象                  scope:常用的值有request、session、prototype（多例）、singleton（单例）    --&gt;    &lt;bean id = &quot;student&quot; class=&quot;cn.java.entity.Student&quot; scope = &quot;prototype&quot;&gt;&lt;/bean&gt;&lt;/beans&gt;</code></pre><p>如何启动</p><pre><code class="Java">public class SpringTest &#123;    @Test    public void test()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Student student = (Student)applicationContext.getBean(&quot;student&quot;);        student.study();    &#125;&#125;</code></pre><p><img src="/picture/Spring%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%90%AF%E5%8A%A8%E7%A8%8B%E5%BA%8F.png" alt="Spring第一个启动程序"></p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><blockquote><p>在Spring框架中，<code>request</code>和<code>session</code>是两个常见的作用域，用于管理Bean的生命周期和可见性。</p><ol><li><p><code>request</code>作用域：当一个Bean被声明为<code>request</code>作用域时，它的实例将与每个HTTP请求相关联，并在请求结束后销毁。这意味着在同一个请求中，多次使用该Bean将得到同一个实例。不同请求之间的Bean实例是独立的。<code>request</code>作用域适用于需要处理每个请求的数据，并且不需要在请求之间共享状态的情况。</p></li><li><p><code>session</code>作用域：当一个Bean被声明为<code>session</code>作用域时，它的实例将与每个用户会话相关联，并在用户会话结束后销毁。用户会话是从用户登录到退出的整个过程。在同一个用户会话中，多次使用该Bean将得到同一个实例。不同用户之间的Bean实例是独立的。<code>session</code>作用域适用于需要在整个用户会话期间保持状态的情况，例如保存用户的登录信息或购物车内容。</p></li></ol><p>要在Spring中声明<code>request</code>或<code>session</code>作用域的Bean，可以使用<code>@Scope</code>注解。例如：</p><pre><code class="java">@Component@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)public class MyRequestBean &#123;    // Bean的定义&#125;@Component@Scope(value = WebApplicationContext.SCOPE_SESSION, proxyMode = ScopedProxyMode.TARGET_CLASS)public class MySessionBean &#123;    // Bean的定义&#125;</code></pre><p>在上面的示例中，<code>MyRequestBean</code>将被声明为<code>request</code>作用域的Bean，而<code>MySessionBean</code>将被声明为<code>session</code>作用域的Bean。请注意，<code>proxyMode</code>属性在使用<code>request</code>或<code>session</code>作用域时通常需要设置为<code>ScopedProxyMode.TARGET_CLASS</code>，以便正确创建代理对象以管理作用域。</p></blockquote><h2 id="传统的单例设计模式"><a href="#传统的单例设计模式" class="headerlink" title="传统的单例设计模式"></a>传统的单例设计模式</h2><pre><code class="Java">//private static final Student stu = new Student();//////饿汉式//public static Student getInstance() &#123;//return stu;//&#125;//        private static Student student = null;    //懒汉式（线程安全问题）    public static Student getInstance() &#123;        if(student != null ) &#123;            return student;        &#125;        return new Student();    &#125;</code></pre><blockquote><p>当谈到传统的单例模式时，可以考虑饿汉式和懒汉式两种实现方式。</p><ol><li>饿汉式（Eager Initialization）单例模式：<br>在饿汉式中，单例对象在类加载时就被实例化。它的特点是在任何情况下都会创建实例，无论是否使用它。</li></ol><pre><code class="java">public class Singleton &#123;    private static final Singleton instance = new Singleton();    private Singleton() &#123;    &#125;    public static Singleton getInstance() &#123;        return instance;    &#125;&#125;</code></pre><p>在饿汉式中，<code>instance</code>是在类加载时创建的，因此保证了线程安全。但是，这种方式可能会在应用程序启动时加载大量资源，因为实例化过程发生在类加载时。如果该单例对象在应用程序运行期间很少使用，这可能会浪费内存。</p><ol start="2"><li>懒汉式（Lazy Initialization）单例模式：<br>在懒汉式中，单例对象在第一次使用时才被实例化。它的特点是延迟加载，只有在需要时才创建实例。</li></ol><pre><code class="java">public class Singleton &#123;    private static Singleton instance;    private Singleton() &#123;    &#125;    public static synchronized Singleton getInstance() &#123;        if (instance == null) &#123;            instance = new Singleton();        &#125;        return instance;    &#125;&#125;</code></pre><p>在懒汉式中，<code>instance</code>是在第一次调用<code>getInstance()</code>方法时才被实例化。为了保证线程安全，可以使用<code>synchronized</code>关键字修饰<code>getInstance()</code>方法。然而，这种方式在高并发环境下可能会引起性能问题，因为每次调用<code>getInstance()</code>都要获取锁。</p><p>需要注意的是，以上示例代码是传统的单例模式实现。在实际开发中，也可以考虑其他更好的单例模式实现方式，如基于静态内部类的单例模式或使用枚举类型实现的单例模式。这些实现方式能够更好地处理线程安全性和懒加载的问题，并提供更简洁的代码。</p></blockquote><h2 id="懒加载"><a href="#懒加载" class="headerlink" title="懒加载"></a>懒加载</h2><pre><code class="xml">    &lt;!-- lazy-init:指定spring容器创建对象的时机，default\true\false             true:懒加载，只有使用某一个对象的时候，这儿对象才会被创建。节省内存资源            default、false ：非懒加载，容器启动的时候对象就会被创建。占用内存资源，使用的较多，防止运行时异常    --&gt;    &lt;bean id = &quot;person&quot;  class=&quot;cn.java.lazy2.Person&quot; lazy-init = &quot;default&quot;&gt;&lt;/bean&gt;</code></pre><blockquote><p>在Spring框架中，<code>lazy-init</code>是一个常用的属性，用于控制Bean的延迟初始化。当设置为<code>lazy-init=&quot;true&quot;</code>时，Bean将在首次被请求时才进行初始化；而当设置为<code>lazy-init=&quot;false&quot;</code>时，Bean将在应用程序启动时立即进行初始化。</p><p>可以在Spring配置文件（如XML配置文件）中使用<code>lazy-init</code>属性来配置Bean的延迟初始化。例如：</p><pre><code class="xml">&lt;bean id=&quot;myBean&quot; class=&quot;com.example.MyBean&quot; lazy-init=&quot;true&quot;&gt;    &lt;!-- Bean的其他配置 --&gt;&lt;/bean&gt;</code></pre><p>在上面的示例中，<code>myBean</code>被配置为延迟初始化。当Spring容器启动时，该Bean不会立即被实例化，而是在首次被请求时才进行初始化。</p><p>延迟初始化的优点是可以节省系统启动时间和资源占用，特别是对于那些很少被使用的大型对象或资源密集型对象。只有当需要使用该Bean时，才会进行初始化，避免不必要的开销。</p><p>需要注意的是，默认情况下，Spring容器中的单例Bean是在容器启动时进行初始化的（<code>lazy-init=&quot;false&quot;</code>）。因此，如果需要将某个单例Bean配置为延迟初始化，需要显式地将<code>lazy-init</code>属性设置为<code>true</code>。</p><p>另外，对于通过注解方式配置的Bean（如使用<code>@Component</code>或<code>@Bean</code>注解），可以使用<code>@Lazy</code>注解来实现延迟初始化。例如：</p><pre><code class="java">@Component@Lazy(true)public class MyBean &#123;    // Bean的定义&#125;</code></pre><p>使用<code>@Lazy(true)</code>注解可以将<code>MyBean</code>配置为延迟初始化的Bean。</p></blockquote><h3 id="DI（依赖注入）"><a href="#DI（依赖注入）" class="headerlink" title="DI（依赖注入）"></a>DI（依赖注入）</h3><p>DI就是给对象赋值</p><ol><li>第一种：通过get、set方法赋值（必须为实体类中的属性提供访问器、修改器）</li></ol><pre><code class="Java">@Test    public void test01()&#123;        ApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        Person person1 =  (Person)applicationContext.getBean(&quot;person&quot;);        person1.setAge(12);        person1.setUsername(&quot;张三&quot;);        System.out.println(person1);    &#125;</code></pre><h5 id="给实体类list、set、map、property集合类型赋值"><a href="#给实体类list、set、map、property集合类型赋值" class="headerlink" title="给实体类list、set、map、property集合类型赋值"></a>给实体类list、set、map、property集合类型赋值</h5><pre><code class="xml">    &lt;bean id =&quot;husbantand&quot; class =&quot;cn.java.di1.Husbantand&quot;&gt;                &lt;property name = &quot;husbantandNameString&quot; value =&quot;王五&quot;&gt;&lt;/property&gt;        &lt;property name = &quot;ageInteger&quot; value = &quot;20&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;wife&quot;  ref = &quot;wife&quot;&gt;&lt;/property&gt;        &lt;property name = &quot;lists&quot; &gt;        &lt;list&gt;        &lt;value&gt;王二&lt;/value&gt;        &lt;value&gt;20&lt;/value&gt;        &lt;ref bean = &quot;wife&quot;/&gt;        &lt;/list&gt;        &lt;/property&gt;        &lt;property name=&quot;set&quot;&gt;        &lt;set&gt;        &lt;value&gt;nu&lt;/value&gt;        &lt;value&gt;19&lt;/value&gt;        &lt;/set&gt;        &lt;/property&gt;        &lt;property name=&quot;maps&quot;&gt;        &lt;map&gt;        &lt;entry key =&quot;husbantandNameString&quot; value =&quot;admin&quot;&gt;&lt;/entry&gt;        &lt;entry key = &quot;ageInteger&quot; value = &quot;人&quot;&gt;&lt;/entry&gt;        &lt;/map&gt;        &lt;/property&gt;        &lt;property name=&quot;prop&quot;&gt;        &lt;props&gt;        &lt;prop key=&quot;driver&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;        &lt;prop key=&quot;url&quot;&gt;jdbc://mysql///dt36&lt;/prop&gt;        &lt;/props&gt;        &lt;/property&gt;            &lt;/bean&gt;</code></pre><ol start="2"><li>第二种：通过有参构造方法</li></ol><pre><code class="xml">&lt;bean id = &quot;person&quot;  class=&quot;cn.java.lazy2.Person&quot; lazy-init = &quot;default&quot;&gt;        &lt;property name = &quot;username&quot; value = &quot;李四&quot;&gt;&lt;/property&gt;        &lt;property name = &quot;age&quot; value = &quot;18&quot;&gt;&lt;/property&gt;&lt;/bean&gt;</code></pre><pre><code class="xml">    &lt;bean id = &quot;wife&quot; class =&quot;cn.java.di1.Wife&quot;&gt;        &lt;property name= &quot;wifeName&quot;  value = &quot;小明&quot;&gt;&lt;/property&gt;        &lt;property name = &quot;genderString&quot; value = &quot;女&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;        &lt;bean id =&quot;husbantand&quot; class =&quot;cn.java.di1.Husbantand&quot;&gt;                &lt;property name = &quot;husbantandNameString&quot; value =&quot;王五&quot;&gt;&lt;/property&gt;        &lt;property name = &quot;ageInteger&quot; value = &quot;20&quot;&gt;&lt;/property&gt;        &lt;property name=&quot;wife&quot;  ref = &quot;wife&quot;&gt;&lt;/property&gt;            &lt;/bean&gt;</code></pre><pre><code class="xml">&lt;!-- 通过构造方法实现依赖注入 --&gt;    &lt;bean id = &quot;person&quot; class = &quot;cn.java.di2.Person&quot;&gt;        &lt;constructor-arg index = &quot;0&quot; type = &quot;java.lang.String&quot; value = &quot;貂蝉&quot;&gt;&lt;/constructor-arg&gt;        &lt;constructor-arg index = &quot;1&quot; type = &quot;java.lang.Integer&quot; value = &quot;18&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><h2 id="通过注解方式实现IOC"><a href="#通过注解方式实现IOC" class="headerlink" title="通过注解方式实现IOC"></a>通过注解方式实现IOC</h2><ol><li><p>在主配置文件中引入注解的相关命名空间</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-2.5.xsd        http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-2.5.xsd&quot;&gt;&lt;!-- 和注解相关的命名空间 --&gt;</code></pre></li><li><p>配置包扫描</p><pre><code class="xml">&lt;!-- 配置包扫描        base-package：包名     --&gt;    &lt;context:component-scan base-package=&quot;cn.java.annotation.ioc1&quot;&gt;&lt;/context:component-scan&gt;</code></pre></li><li><p>如果某一个类的对象创建过程交给spring容器来处理，则需要在这个类的上面添加注解</p><p> （@Component（控制层）、@Service、@Repository（dao层）、@controller、@Scope{单例，多例}）</p></li></ol><h2 id="通过注解方式实现DI"><a href="#通过注解方式实现DI" class="headerlink" title="通过注解方式实现DI"></a>通过注解方式实现DI</h2><p>如果某一类中的属性需要通过注解的方式实现注入</p><p>@Autowired{快速生成new}</p><blockquote><p>在Spring中，<code>@Autowired</code>注解用于自动装配依赖项，它可以应用在字段、构造函数、Setter方法或者普通方法上。</p><p>以下是<code>@Autowired</code>的用法示例：</p><ol><li>字段注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    @Autowired    private MyDependency myDependency;    // ...&#125;</code></pre><ol start="2"><li>构造函数注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    private MyDependency myDependency;    @Autowired    public MyClass(MyDependency myDependency) &#123;        this.myDependency = myDependency;    &#125;    // ...&#125;</code></pre><ol start="3"><li>Setter方法注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    private MyDependency myDependency;    @Autowired    public void setMyDependency(MyDependency myDependency) &#123;        this.myDependency = myDependency;    &#125;    // ...&#125;</code></pre><ol start="4"><li>方法注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    private MyDependency myDependency;    @Autowired    public void injectDependency(MyDependency myDependency) &#123;        this.myDependency = myDependency;    &#125;    // ...&#125;</code></pre><p>注意事项：</p><ul><li>在使用<code>@Autowired</code>注解时，Spring会根据类型进行自动装配。如果存在多个匹配的候选项，可以使用<code>@Qualifier</code>注解指定要注入的具体实例。</li><li><code>@Autowired</code>注解默认情况下要求依赖项必须存在，如果找不到匹配的依赖项，将抛出异常。可以使用<code>required = false</code>参数来解除这种要求。</li><li><code>@Autowired</code>注解还可以与<code>@Qualifier</code>、<code>@Primary</code>、<code>@Resource</code>等注解一起使用，以更精确地指定要注入的依赖项。</li></ul><p>除了<code>@Autowired</code>注解，Spring还提供了其他的自动装配注解，如<code>@Inject</code>、<code>@Resource</code>等，它们可以实现类似的自动装配功能，但具体用法和细节可能有所不同。</p><p>总结：<code>@Autowired</code>注解是Spring中实现自动装配的关键注解，它可以方便地将依赖项注入到需要的地方，简化了代码的编写和配置。</p></blockquote><p>@Resource注解</p><blockquote><p>在Spring中，<code>@Resource</code>注解用于进行依赖注入，类似于<code>@Autowired</code>注解。它提供了一种通过名称或类型进行自动装配的方式。</p><p>以下是<code>@Resource</code>注解的用法示例：</p><ol><li>通过名称进行注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    @Resource(name = &quot;myDependency&quot;)    private MyDependency myDependency;    // ...&#125;</code></pre><ol start="2"><li>通过类型进行注入：</li></ol><pre><code class="java">@Componentpublic class MyClass &#123;    @Resource    private MyDependency myDependency;    // ...&#125;</code></pre><p>注意事项：</p><ul><li>默认情况下，<code>@Resource</code>注解通过名称进行自动装配。当没有提供<code>name</code>属性时，它会根据字段名或方法名与依赖项的名称进行匹配。如果找不到匹配的依赖项，将抛出异常。可以使用<code>name</code>属性明确指定要注入的依赖项的名称。</li><li>如果提供了<code>name</code>属性，<code>@Resource</code>注解将会按照指定的名称进行匹配。这个名称可以是Spring bean的名称或者是其他命名资源的名称。</li><li><code>@Resource</code>注解也可以应用在Setter方法上进行依赖注入。</li><li>和<code>@Autowired</code>注解一样，<code>@Resource</code>注解也可以与<code>@Qualifier</code>注解一起使用，以指定要注入的具体实例。</li><li><code>@Resource</code>注解是Java EE的标准注解，而<code>@Autowired</code>注解是Spring的特有注解。</li></ul><p>总结：<code>@Resource</code>注解提供了一种通过名称或类型进行依赖注入的方式，在Spring中可以用于替代或补充<code>@Autowired</code>注解。它可以方便地将依赖项注入到需要的地方，实现自动装配的功能。</p></blockquote><h2 id="AOP：面向切面"><a href="#AOP：面向切面" class="headerlink" title="AOP：面向切面"></a>AOP：面向切面</h2><ol><li><p>切面—Security、Logging、GC</p></li><li><p>通知：（切面中的方法为通知）</p><ol><li><p>前置通知—Security（方法）（在目标方法前面执行的通知为前置通知）</p><pre><code class="xml">&lt;aop:aspect ref = &quot;security&quot;&gt;            &lt;!-- 配置通知：                    method：通知名字                    printcut-ref ：指入切入点                         --&gt;                &lt;aop:before mothod = &quot;checkSecurity&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:before&gt;            &lt;/aop:aspect&gt;</code></pre></li><li><p>后置通知—Logging、GC（方法）（在目标方法后面执行的通知为后置通知）</p><pre><code class="xml">&lt;aop:aspect ref = &quot;logging&quot;&gt;                &lt;aop:after method = &quot;logger&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:after&gt;            &lt;/aop:aspect&gt;                        &lt;aop:aspect ref = &quot;gC&quot;&gt;                &lt;aop:after method = &quot;clearly&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:after&gt;            &lt;/aop:aspect&gt;</code></pre></li><li><p>带返回值的后置通知</p></li><li><p>环绕通知</p><pre><code class="xml">&lt;!-- 配置环绕通知 --&gt;            &lt;aop:aspect ref = &quot;auth&quot;&gt;                &lt;aop:round method = &quot;isLogin&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:round&gt;            &lt;/aop:aspect&gt;</code></pre></li><li><p>异常通知</p><pre><code class="xml">&lt;!-- 配置异常通知                 public void handAllException(Throwable ex) &#123;                参数要一致            --&gt;            &lt;aop:aspect ref = &quot;glibal&quot;&gt;                &lt;aop:after-throwing method = &quot;handAllException&quot; pointcut-ref = &quot;mdl&quot; throwing = &quot;ex&quot;/&gt;            &lt;/aop:aspect&gt;</code></pre></li><li><p>最终通知</p></li></ol></li><li><p>目标类—cn.java.service（核心操作所在的类）</p></li><li><p>目标方法—功能（目标类所在的方法）</p></li><li><p>切入点</p></li></ol><pre><code class="xml">&lt;aop:pointcut expression = &quot;execution(* cn.java.aop2.MobileDaoImpl.*(..))&quot; id = &quot;mdl&quot;&gt;&lt;/aop:pointcut&gt; </code></pre><ol start="6"><li>织入—把这一段编写成代码就是织入</li></ol><p><img src="/picture/AOP.jpg"></p><h4 id="AOP使用步骤"><a href="#AOP使用步骤" class="headerlink" title="AOP使用步骤"></a>AOP使用步骤</h4><ol><li><p>导入jar包</p><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;       xmlns:context=&quot;http://www.springframework.org/schema/context&quot;       xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot;       xsi:schemaLocation=&quot;        http://www.springframework.org/schema/beans         http://www.springframework.org/schema/beans/spring-beans-2.5.xsd        http://www.springframework.org/schema/context         http://www.springframework.org/schema/context/spring-context-2.5.xsd        http://www.springframework.org/schema/lang         http://www.springframework.org/schema/lang/spring-lang-2.5.xsd&quot;&gt;    &lt;!-- 相关的命名空间 --&gt;</code></pre></li><li><p>书写配置文件</p><pre><code class="xml">&lt;!-- 目标类 --&gt;        &lt;bean id= &quot;mobileDaoImpl&quot; class= &quot;cn.java.aop2.MobileDaoImpl&quot;&gt;&lt;/bean&gt;        &lt;!-- 切面类 --&gt;        &lt;bean id= &quot;logging&quot; class= &quot;cn.java.aop2.Logging&quot;&gt;&lt;/bean&gt;        &lt;bean id= &quot;gC&quot; class= &quot;cn.java.aop2.GC&quot;&gt;&lt;/bean&gt;        &lt;bean id= &quot;security&quot; class= &quot;cn.java.aop2.Security&quot;&gt;&lt;/bean&gt;                        &lt;!-- 配置AOP --&gt;        &lt;aop:config&gt;                        &lt;!-- 配置切入点                    expression:切入点表达式execution（* com.xyz.service.AccountService.*（..））                    id：切入点的id                                 --&gt;            &lt;aop:pointcut expression = &quot;execution(* cn.java.aop2.MobileDaoImpl.*(..))&quot; id = &quot;mdl&quot;&gt;&lt;/aop:pointcut&gt;                         &lt;!-- 配置切面 --&gt;            &lt;aop:aspect ref = &quot;security&quot;&gt;            &lt;!-- 配置通知：                    method：通知名字                    printcut-ref ：指入切入点                         --&gt;                &lt;aop:before mothod = &quot;checkSecurity&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:before&gt;            &lt;/aop:aspect&gt;                                    &lt;aop:aspect ref = &quot;logging&quot;&gt;                &lt;aop:after method = &quot;logger&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:after&gt;            &lt;/aop:aspect&gt;                        &lt;aop:aspect ref = &quot;gC&quot;&gt;                &lt;aop:after method = &quot;clearly&quot; pointcut-ref = &quot;mdl&quot;&gt;&lt;/aop:after&gt;            &lt;/aop:aspect&gt;                                &lt;/aop:config&gt;</code></pre></li><li><p>启动框架测试</p></li></ol><h2 id="spring-mybatis的整合"><a href="#spring-mybatis的整合" class="headerlink" title="spring+mybatis的整合"></a>spring+mybatis的整合</h2><ol><li><p>导入jar包</p></li><li><p>书写主配置文件（applicationContext.xml、mybatis.xml）</p><pre><code class="xml">applicationContext.xml头文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;     xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-4.2.xsd&quot;&gt;              &lt;/beans&gt;</code></pre><pre><code class="xml">mybatis.xml头文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置数据源 --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydatabase&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;magichell&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre><p> 配置数据库（直接在applicationContext.xml配置）</p><pre><code class="xml">&lt;!-- 配置数据源 --&gt;       &lt;bean id = &quot;basicDataSource&quot; class = &quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;               &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost:3306/mydatabase&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;username&quot; value = &quot;root&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;password&quot; value = &quot;magichell&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;</code></pre><p> 扫描书写sql配置文件</p><pre><code class="xml">       &lt;!-- 扫描书写sql语句的配置文件 --&gt;       &lt;bean id = &quot;sqlSessionFactoryBean&quot; class = &quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;               &lt;!-- 指定数据源 --&gt;               &lt;property name=&quot;dataSource&quot; ref = &quot;basicDataSource&quot;&gt;&lt;/property&gt;               &lt;!-- 指定书写sql语句的xml文件路径 --&gt;               &lt;property name=&quot;mapperLocations&quot; value = &quot;classpath*:cn/java/dao/*.xml&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;</code></pre><p> 扫描dao层类</p><pre><code class="xml">       &lt;!-- 扫描dao层类 --&gt;       &lt;bean id = &quot;mapperScannerConfigurer&quot; class = &quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt;               &lt;property name = &quot;basePackage&quot;  value = &quot;cn.java.dao&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;</code></pre></li><li><p>启动框架测试</p></li></ol><h2 id="Mybatis介绍"><a href="#Mybatis介绍" class="headerlink" title="Mybatis介绍"></a>Mybatis介绍</h2><p>mybatis驱动</p><pre><code class="xml">        &lt;!--Mybatis核心依赖--&gt;        &lt;!-- https://mvnrepository.com/artifact/org.mybatis/mybatis --&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;            &lt;version&gt;3.5.5&lt;/version&gt;        &lt;/dependency&gt;        &lt;!--mysql 对应版本的连接器驱动--&gt;        &lt;dependency&gt;            &lt;groupId&gt;mysql&lt;/groupId&gt;            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;            &lt;version&gt;8.0.32&lt;/version&gt;        &lt;/dependency&gt;</code></pre><p>书写主配置文件</p><ol><li><p>在java中如何去写mysql脚本的xml</p><pre><code class="xml">头文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE mapper        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;/mapper&gt;</code></pre><p> <img src="/picture/mysql%E5%A4%B4%E6%96%87%E4%BB%B6.png"></p></li></ol><h5 id="sqlsession、SqlSessionFactory-、SqlSessionFactoryBuilder是什么"><a href="#sqlsession、SqlSessionFactory-、SqlSessionFactoryBuilder是什么" class="headerlink" title="sqlsession、SqlSessionFactory 、SqlSessionFactoryBuilder是什么"></a>sqlsession、SqlSessionFactory 、SqlSessionFactoryBuilder是什么</h5><blockquote><p><code>SqlSession</code>、<code>SqlSessionFactory</code>和<code>SqlSessionFactoryBuilder</code>是Java中用于管理和执行SQL语句的类和接口，通常用于与关系型数据库进行交互。</p><ol><li><p><code>SqlSessionFactoryBuilder</code>是一个用于创建<code>SqlSessionFactory</code>实例的构建器类。它负责读取配置文件（如XML文件）或直接从代码中的配置信息构建<code>SqlSessionFactory</code>对象。它是一个一次性的对象，创建完<code>SqlSessionFactory</code>后就可以丢弃。</p></li><li><p><code>SqlSessionFactory</code>是一个线程安全的类，用于创建<code>SqlSession</code>实例。它是基于数据库配置信息和映射文件创建的，可以通过<code>SqlSessionFactory</code>打开新的<code>SqlSession</code>对象。<code>SqlSessionFactory</code>是一个重量级的对象，一般在应用程序的生命周期内只需要创建一个实例。</p></li><li><p><code>SqlSession</code>是与数据库交互的主要接口。它提供了执行SQL语句、提交事务、获取映射器（Mapper）等方法。每个线程都应该拥有自己的<code>SqlSession</code>实例，并在使用完毕后关闭它。</p></li></ol><p>总结：<br><code>SqlSessionFactoryBuilder</code>用于创建<code>SqlSessionFactory</code>实例，而<code>SqlSessionFactory</code>用于创建<code>SqlSession</code>实例。<code>SqlSession</code>提供了与数据库交互的方法，包括执行SQL语句和管理事务等操作。这些类和接口通常与MyBatis等ORM（对象关系映射）框架一起使用，用于简化Java与数据库之间的交互。</p></blockquote><pre><code class="Java">    public void selectEmp() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        SqlSession sqlSession = ssf.openSession();        List&lt;Object&gt; emp = sqlSession.selectList(&quot;com.java.dao.impl.EmpDaoImpl.selectEmp&quot;);        emp.forEach(temp -&gt; System.out.println(temp));    &#125;</code></pre><p><img src="/picture/mybatis%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C%E6%9F%A5%E8%AF%A2.png"></p><h4 id="Mybatis中添加数据"><a href="#Mybatis中添加数据" class="headerlink" title="Mybatis中添加数据"></a>Mybatis中添加数据</h4><pre><code class="Java">@Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    /**     * 查询emp表中的所有数据     */    @Test    public void selectEmp() throws IOException &#123;        List&lt;Object&gt; emp = sqlSession.selectList(&quot;com.java.dao.impl.EmpDaoImpl.selectEmp&quot;);        emp.forEach(temp -&gt; System.out.println(temp));    &#125;</code></pre><pre><code class="xml">    &lt;!--        select标签：存放的是sql语句        resultType；指定返回类型        id属性：与dao类的方法名保持一致        parameterType:指定参数类型    --&gt;    &lt;select id=&quot;selectEmp&quot; resultType=&quot;Map&quot;&gt;        SELECT * FROM books;    &lt;/select&gt;    &lt;select id=&quot;selectOne&quot; resultType=&quot;Map&quot;&gt;        SELECT * FROM books WHERE id = 1;    &lt;/select&gt;    &lt;select id=&quot;selectone&quot; resultType=&quot;Map&quot; parameterType=&quot;Long&quot;&gt;        SELECT * FROM books WHERE id = #&#123;0&#125;;    &lt;/select&gt;    &lt;!-- 带多个参数的查询语句 --&gt;    &lt;select id=&quot;select2&quot; resultType=&quot;Map&quot; parameterType=&quot;Map&quot;&gt;        SELECT * FROM books WHERE price &amp;lt; #&#123;price&#125; and num &amp;gt; #&#123;num&#125;;    &lt;/select&gt;</code></pre><h3 id="执行结果"><a href="#执行结果" class="headerlink" title="执行结果"></a>执行结果</h3><p><img src="/picture/Mybatis%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h3 id="Mybatis添加数据"><a href="#Mybatis添加数据" class="headerlink" title="Mybatis添加数据"></a>Mybatis添加数据</h3><pre><code class="Java"> @Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    @Test    public void  test06() &#123;        Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();        paramMap.put(&quot;bookName&quot;,&quot;Mybatis的作业&quot;);        paramMap.put(&quot;price&quot; , 50F);        paramMap.put(&quot;num&quot; , 10);        int sql = sqlSession.insert(&quot;com.java.dao.impl.EmpDaoImpl.insertOne&quot;,paramMap);        sqlSession.commit();        //提交事务        System.out.println(sql);    &#125;</code></pre><pre><code class="xml">    &lt;!-- 添加一条数据            备注：增删改标签不需要显示指定返回类型，默认返回类型都为int     --&gt;    &lt;insert id=&quot;insertOne&quot; parameterType=&quot;Map&quot;&gt;        INSERT INTO Books VALUES (null,#&#123;bookName&#125;,#&#123;price&#125;,#&#123;num&#125;);    &lt;/insert&gt;</code></pre><p>运行结果</p><p><img src="/picture/Mybatis%E6%B7%BB%E5%8A%A0%E7%BB%93%E6%9E%9C%E8%BF%90%E8%A1%8C%E7%A4%BA%E6%84%8F%E5%9B%BE.png"></p><h3 id="Myabtis删除数据"><a href="#Myabtis删除数据" class="headerlink" title="Myabtis删除数据"></a>Myabtis删除数据</h3><pre><code class="Java">    private SqlSession sqlSession = null;    @Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    //提交事务    @After    public void destory()&#123;        sqlSession.commit();    &#125;        @Test    public void test07()&#123;        int flag = sqlSession.delete(&quot;com.java.dao.impl.EmpDaoImpl.deleteOne&quot;,1L);        System.out.println(flag);    &#125;</code></pre><pre><code class="xml">    &lt;delete id=&quot;deleteOne&quot; parameterType=&quot;Long&quot;&gt;        DELETE FROM books WHERE id = #&#123;0&#125;    &lt;/delete&gt;</code></pre><h3 id="myabtis改数据"><a href="#myabtis改数据" class="headerlink" title="myabtis改数据"></a>myabtis改数据</h3><pre><code class="Java">    private SqlSession sqlSession = null;    @Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    //提交事务    @After    public void destory()&#123;        sqlSession.commit();    &#125;    @Test    public void test08()&#123;        Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();        paramMap.put(&quot;bookName&quot;,&quot;Mybatis&quot;);        paramMap.put(&quot;price&quot; , 50F);        paramMap.put(&quot;num&quot; , 1999);        paramMap.put(&quot;id&quot;,4);        int flg = sqlSession.update(&quot;com.java.dao.impl.EmpDaoImpl.updateOne&quot;,paramMap);    &#125;</code></pre><pre><code class="xml">    &lt;update id=&quot;updateOne&quot; parameterType=&quot;Map&quot;&gt;        UPDATE books SET bookName = #&#123;bookName&#125;,price = #&#123;price&#125;,num= #&#123;num&#125; WHERE id = #&#123;id&#125;    &lt;/update&gt;</code></pre><h3 id="在Mybatis-xml可以配置别名"><a href="#在Mybatis-xml可以配置别名" class="headerlink" title="在Mybatis.xml可以配置别名"></a>在Mybatis.xml可以配置别名</h3><pre><code class="xml">    &lt;!-- 配置别名            typeAliases属性:自定义实体类配置别名            type属性：指定自定义类的具体路径            alias属性：为当前自定义类取个别名    --&gt;    &lt;typeAliases&gt;        &lt;typeAlias type=&quot;com.java.pojo.Emp&quot; alias=&quot;Emp&quot;&gt;&lt;/typeAlias&gt;    &lt;/typeAliases&gt;</code></pre><h3 id="，-取值区别"><a href="#，-取值区别" class="headerlink" title="#，$取值区别"></a>#，$取值区别</h3><ol><li>#在取值时，会将所有数据当作字符串处理，自动添加上单引号；$取值时，将参数当作普通文本处理，不添加任何的单引号</li><li>#取值时可以防止SQL注入，$取值时不能防止SQL注入</li></ol><blockquote><p>在MyBatis中，<code>#</code>和<code>$</code>符号都用于在SQL语句中插入参数值，但它们在取值和处理方式上有一些区别。</p><ol><li><p><code>#</code>符号（预编译）：</p><ul><li><code>#</code>符号用于插入预编译参数，它会将参数值以安全的方式进行替换，防止SQL注入攻击。</li><li>在使用<code>#</code>符号时，MyBatis会将参数值作为一个占位符，并将其转义后放入SQL语句中，然后通过PreparedStatement进行预编译。</li><li>举个例子：<code>SELECT * FROM users WHERE id = #&#123;userId&#125;</code>，这里的<code>#&#123;userId&#125;</code>会被替换为预编译参数，如<code>SELECT * FROM users WHERE id = ?</code>，然后将实际参数值传递给PreparedStatement进行安全地执行。</li></ul></li><li><p><code>$</code>符号（字符串拼接）：</p><ul><li><code>$</code>符号用于直接替换参数值，它将参数值字面地嵌入SQL语句中。</li><li>在使用<code>$</code>符号时，MyBatis会简单地将参数值直接替换到SQL语句中，不进行预编译或转义操作。</li><li>举个例子：<code>SELECT * FROM users WHERE id = $&#123;userId&#125;</code>，这里的<code>$&#123;userId&#125;</code>会被替换为实际的参数值，如<code>SELECT * FROM users WHERE id = 1</code>，直接将参数值替换到SQL语句中。</li></ul></li></ol><p>需要注意的是，使用<code>$</code>符号存在一定的风险，因为参数值会直接替换到SQL语句中，如果参数值来自用户输入且未经过充分验证和转义，可能会导致SQL注入攻击。为了避免这种情况，建议在可能存在安全风险的地方使用<code>#</code>符号进行参数替换。</p><p>综上所述，使用<code>#</code>符号可以提供更安全的参数处理方式，而使用<code>$</code>符号则更适用于一些简单的字符串拼接场景。</p></blockquote><h3 id="Mybatis模糊查询"><a href="#Mybatis模糊查询" class="headerlink" title="Mybatis模糊查询"></a>Mybatis模糊查询</h3><pre><code class="Java">private SqlSession sqlSession = null;    @Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    @Test    public void test09()&#123;        Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();        paramMap.put(&quot;bookName&quot;,&quot;Mybatis的作业&quot;);        paramMap.put(&quot;num&quot; , 1);        List&lt;Map&lt;String,Object&gt;&gt; flg = sqlSession.selectList(&quot;com.java.dao.impl.EmpDaoImpl.selcectMoHu&quot;,paramMap);        System.out.println(flg);    &#125;</code></pre><pre><code class="xml">    &lt;!-- 模糊查询 --&gt;    &lt;select id=&quot;selcectMoHu&quot; parameterType=&quot;Map&quot; resultType=&quot;Map&quot;&gt;        SELECT * FROM books WHERE bookName LIKE &#39;%$&#123;bookName&#125;%&#39; AND num &gt;#&#123;num&#125;;    &lt;/select&gt;    &lt;select id=&quot;selcectMoHu2&quot; parameterType=&quot;Map&quot; resultType=&quot;Map&quot;&gt;        SELECT * FROM books WHERE bookName LIKE CONCAT(&#39;%&#39;,&#39;#&#123;bookName&#125;&#39;,&#39;%&#39;) AND num &gt;#&#123;num&#125;;    &lt;/select&gt;</code></pre><p><img src="/picture/mybatis%E6%A8%A1%E7%B3%8A%E6%9F%A5%E8%AF%A2%E8%BF%90%E8%A1%8C%E6%95%88%E6%9E%9C%E5%9B%BE.png"></p><h3 id="使用sql标签抽取公共字段"><a href="#使用sql标签抽取公共字段" class="headerlink" title="使用sql标签抽取公共字段"></a>使用sql标签抽取公共字段</h3><pre><code class="xml">&lt;!-- 使用sql标签抽取公共字段 --&gt;    &lt;sql id=&quot;commonFiled&quot;&gt;        id,bookName,price,num    &lt;/sql&gt;            &lt;!--        select标签：存放的是sql语句        resultType；指定返回类型        id属性：与dao类的方法名保持一致        parameterType:指定参数类型    --&gt;    &lt;select id=&quot;selectEmp&quot; resultType=&quot;Map&quot;&gt;        SELECT &lt;include refid=&quot;commonFiled&quot;&gt;&lt;/include&gt; FROM books;    &lt;/select&gt;</code></pre><h3 id="动态查询SQL"><a href="#动态查询SQL" class="headerlink" title="动态查询SQL"></a>动态查询SQL</h3><p><u>动态SQL：包括动态查询SQL、动态修改SQL，sql语句会变化的sql语句</u> </p><pre><code class="Java">@Before    public void init() throws IOException &#123;        //sqlsession---------SqlSessionFactory ------SqlSessionFactoryBuilder        /**         * 1. 得到SqlSessionFactoryBuilder对象         * 2. 通过SqlSessionFactoryBuilder对象得到SqlSessionFactory对象         * 3. 得到sqlsession对象         * 4. 执行对应的sql语句，接受结果，对结果进行遍历         */        SqlSessionFactoryBuilder ssfb = new SqlSessionFactoryBuilder();        InputStream ins = Resources.getResourceAsStream(&quot;mybatis.xml&quot;);        SqlSessionFactory ssf = ssfb.build(ins);        sqlSession = ssf.openSession();    &#125;    //动态查询    @Test    public void test010()&#123;        Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();        List&lt;Map&lt;String,Object&gt;&gt; flg = sqlSession.selectList(&quot;com.java.dao.impl.EmpDaoImpl.selectDynameic&quot;,paramMap);        System.out.println(flg);    &#125;</code></pre><pre><code class="xml">&lt;!-- 动态查询sql语句 --&gt;    &lt;select id=&quot;selectDynameic&quot; parameterType=&quot;Map&quot; resultType=&quot;Map&quot;&gt;        SELECT * FROM computers        &lt;where&gt;            &lt;if test = &quot;brand!=null and brand != &#39;&#39;&quot;&gt;                brand = #&#123;brand&#125;            &lt;/if&gt;            &lt;if test = &quot;startPrice!=null and startPrice != &#39;&#39;&quot;&gt;                AND price &amp;gt;= #&#123;startPrice&#125;            &lt;/if&gt;            &lt;if test = &quot;endPrice!=null and endPrice != &#39;&#39;&quot;&gt;                AND price &amp;lt;= #&#123;endPrice&#125;            &lt;/if&gt;            &lt;if test = &quot;runMem!=null and runMem != &#39;&#39;&quot;&gt;                AND runMem = #&#123;runMem&#125;            &lt;/if&gt;            &lt;if test = &quot;xianKa!=null and xianKa != &#39;&#39;&quot;&gt;                AND xianKa = #&#123;xianKa&#125;            &lt;/if&gt;            &lt;if test = &quot;cpu!=null and cpu != &#39;&#39;&quot;&gt;                AND cpu = #&#123;cpu&#125;            &lt;/if&gt;        &lt;/where&gt;</code></pre><p><img src="/picture/Mybatis%E5%8A%A8%E6%80%81%E6%9F%A5%E8%AF%A2.png"></p><h3 id="动态修改"><a href="#动态修改" class="headerlink" title="动态修改"></a>动态修改</h3><pre><code class="Java">    //动态修改    @Test    public void test011()&#123;        Map&lt;String,Object&gt; paramMap = new HashMap&lt;&gt;();        paramMap.put(&quot;brand&quot;,&quot;联想2525&quot;);        paramMap.put(&quot;id&quot;,2L);        int flg = sqlSession.update(&quot;com.java.dao.impl.EmpDaoImpl.updateDynameic&quot;,paramMap);        System.out.println(flg);    &#125;</code></pre><pre><code class="xml">    &lt;!-- 动态修改sql语句--&gt;    &lt;update id=&quot;updateDynameic&quot; parameterType=&quot;Map&quot; &gt;        UPDATE computers SET        &lt;if test=&quot;brand!=null and brand != &#39;&#39;&quot;&gt;            brand=#&#123;brand&#125;        &lt;/if&gt;        &lt;if test=&quot;runMem!=null and runMem != &#39;&#39;&quot;&gt;            runMem=#&#123;runMem&#125;,        &lt;/if&gt;        &lt;if test=&quot;price!=null and price != &#39;&#39;&quot;&gt;            price=#&#123;price&#125;,        &lt;/if&gt;        &lt;if test=&quot;cpu!=null and cpu != &#39;&#39;&quot;&gt;            cpu=#&#123;cpu&#125;,        &lt;/if&gt;        &lt;if test=&quot;xianKa!=null and xianKa != &#39;&#39;&quot;&gt;            xianKa=#&#123;xianKa&#125;,        &lt;/if&gt;        WHERE id=#&#123;id&#125;    &lt;/update&gt;</code></pre><h4 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h4><pre><code class="xml">    &lt;update id=&quot;updateDynameic01&quot; parameterType=&quot;Map&quot; &gt;        UPDATE computers        &lt;trim prefix=&quot;SET&quot; suffixOverrides=&quot;,&quot;&gt;            &lt;if test=&quot;brand!=null and brand != &#39;&#39;&quot;&gt;                brand=#&#123;brand&#125;,            &lt;/if&gt;            &lt;if test=&quot;runMem!=null and runMem != &#39;&#39;&quot;&gt;                runMem=#&#123;runMem&#125;,            &lt;/if&gt;            &lt;if test=&quot;price!=null and price != &#39;&#39;&quot;&gt;                price=#&#123;price&#125;,            &lt;/if&gt;            &lt;if test=&quot;cpu!=null and cpu != &#39;&#39;&quot;&gt;                cpu=#&#123;cpu&#125;,            &lt;/if&gt;            &lt;if test=&quot;xianKa!=null and xianKa != &#39;&#39;&quot;&gt;                xianKa=#&#123;xianKa&#125;,            &lt;/if&gt;        &lt;/trim&gt;            WHERE id=#&#123;id&#125;    &lt;/update&gt;</code></pre><h3 id="一对一的关系"><a href="#一对一的关系" class="headerlink" title="一对一的关系"></a>一对一的关系</h3><pre><code class="xml">    &lt;!-- 描述Husband，Wife，sql语句字段的映射关系 --&gt;    &lt;!--    resultMap标签:描述JavaBean与数据库表中的字段、JavaBean与IavaBean回的关系                id属性:为当前标签体中的内容取一个唯一表示                type属性:需要被描述的实体美的名宁                result标签:用来表达JavaBean的属性与数据库表中字段的映射                property属性:javaBean的属性                column属性:表字段属性                javaType属性:javaBean的所性的类型                jdbcTvpe属性(可以省略): 表字段属性的类型    --&gt;    &lt;resultMap id=&quot;hus&quot; type=&quot;com.java.pojo.Husband&quot;&gt;        &lt;result property=&quot;husid&quot; javaType=&quot;Long&quot; column=&quot;husid&quot; jdbcType=&quot;BIGINT&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;age&quot; javaType=&quot;Integer&quot; column=&quot;age&quot; jdbcType=&quot;INTEGER&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;gender&quot; javaType=&quot;String&quot; column=&quot;gender&quot; jdbcType=&quot;VARCHAR&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;husbandname&quot; javaType=&quot;String&quot; column=&quot;husbandname&quot; jdbcType=&quot;VARCHAR&quot;&gt;&lt;/result&gt;        &lt;association property=&quot;wife&quot; javaType=&quot;com.java.pojo.Wife&quot;&gt;            &lt;result property=&quot;wifeid&quot; javaType=&quot;Long&quot; column=&quot;wifeid&quot; jdbcType=&quot;BIGINT&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;nianlin&quot; javaType=&quot;Integer&quot; column=&quot;nianlin&quot; jdbcType=&quot;INTEGER&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;sex&quot; javaType=&quot;String&quot; column=&quot;sex&quot; jdbcType=&quot;VARCHAR&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;wifename&quot; javaType=&quot;String&quot; column=&quot;wifename&quot; jdbcType=&quot;VARCHAR&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;hid&quot; javaType=&quot;Long&quot; column=&quot;hid&quot; jdbcType=&quot;BIGINT&quot;&gt;&lt;/result&gt;        &lt;/association&gt;    &lt;/resultMap&gt;    &lt;!-- 一对一的关联关系 --&gt;    &lt;!-- resultMap 替换上面id --&gt;    &lt;select id=&quot;selectByOne2One&quot; parameterType=&quot;String&quot; resultMap=&quot;hus&quot;&gt;        SELECT * FROM husband hs INNER JOIN wife w            ON hs.husid=w.hid WHERE hs.husbandname = #&#123;0&#125;;    &lt;/select&gt;</code></pre><h4 id="一对多关系"><a href="#一对多关系" class="headerlink" title="一对多关系"></a>一对多关系</h4><pre><code class="xml">&lt;!-- 一对多的关系 --&gt;    &lt;resultMap id=&quot;uMap&quot; type=&quot;com.java.pojo.User&quot;&gt;        &lt;result property=&quot;id&quot; javaType=&quot;Long&quot; column=&quot;id&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;uName&quot; javaType=&quot;String&quot; column=&quot;uName&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;phone&quot; javaType=&quot;String&quot; column=&quot;phone&quot;&gt;&lt;/result&gt;        &lt;result property=&quot;address&quot; javaType=&quot;String&quot; column=&quot;address&quot;&gt;&lt;/result&gt;        &lt;collection property=&quot;orderList&quot; ofType=&quot;com.java.pojo.Order&quot;&gt;            &lt;result property=&quot;orderId&quot; javaType=&quot;Long&quot; column=&quot;orderId&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;remark&quot; javaType=&quot;String&quot; column=&quot;remark&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;orderNo&quot; javaType=&quot;String&quot; column=&quot;orderNo&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;cost&quot; javaType=&quot;Float&quot; column=&quot;cost&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;createTime&quot; javaType=&quot;String&quot; column=&quot;createTime&quot;&gt;&lt;/result&gt;            &lt;result property=&quot;User&quot; javaType=&quot;Long&quot; column=&quot;User&quot;&gt;&lt;/result&gt;        &lt;/collection&gt;    &lt;/resultMap&gt;    &lt;select id=&quot;selectByOne2Two&quot; parameterType=&quot;String&quot; resultMap=&quot;uMap&quot;&gt;        SELECT * FROM orders o INNER JOIN users u        ON o.userID = u.id WHERE u.phone = #&#123;0&#125;    &lt;/select&gt;</code></pre><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><h5 id="pagehelper"><a href="#pagehelper" class="headerlink" title="pagehelper"></a>pagehelper</h5><blockquote><p>MyBatis 是一款优秀的持久层框架，而 PageHelper 是一个为 MyBatis 提供分页查询功能的插件。它简化了在数据库中进行分页查询的操作，提供了方便的 API 和配置方式。</p><p>使用 PageHelper 插件，你可以轻松地实现数据库分页查询功能。下面是使用 PageHelper 的基本步骤：</p><ol><li><p>引入 PageHelper 依赖：在你的项目中，需要添加 PageHelper 的依赖。如果使用 Maven，可以在 pom.xml 文件中添加以下依赖配置：</p><pre><code class="xml">&lt;dependency&gt;    &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;    &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;    &lt;version&gt;最新版本&lt;/version&gt;&lt;/dependency&gt;</code></pre></li><li><p>配置 PageHelper：在 MyBatis 的配置文件（通常是 <code>mybatis-config.xml</code>）中，添加 PageHelper 的配置信息。配置信息可以包括分页插件的属性和参数，例如数据库类型、分页参数名称等。以下是一个简单的配置示例：</p><pre><code class="xml">&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;        &lt;property name=&quot;helperDialect&quot; value=&quot;数据库方言&quot;/&gt;        &lt;property name=&quot;params&quot; value=&quot;pageNum=pageNumKey;pageSize=pageSizeKey;&quot;/&gt;    &lt;/plugin&gt;&lt;/plugins&gt;</code></pre></li><li><p>在代码中使用分页功能：在你的查询代码中，使用 PageHelper.startPage 方法来开启分页功能，并指定页码和每页显示的记录数。例如：</p><pre><code class="java">// 第一个参数为页码，第二个参数为每页显示的记录数PageHelper.startPage(1, 10);List&lt;User&gt; userList = userDao.getAllUsers();</code></pre></li><li><p>获取分页结果：执行完查询语句后，PageHelper 会自动将查询结果封装成一个 PageInfo 对象，其中包含了分页信息和查询结果列表。你可以通过 PageInfo 对象获取总记录数、总页数以及当前页的数据等。例如：</p><pre><code class="java">PageInfo&lt;User&gt; pageInfo = new PageInfo&lt;&gt;(userList);int total = pageInfo.getTotal(); // 总记录数int pages = pageInfo.getPages(); // 总页数List&lt;User&gt; result = pageInfo.getList(); // 当前页的数据列表</code></pre></li></ol><p>这就是使用 PageHelper 插件实现分页查询的基本步骤。通过简单的配置和调用，你可以方便地在 MyBatis 中实现数据库分页查询功能。记得根据实际情况配置合适的分页参数和数据库方言，以及处理异常情况。</p></blockquote><h2 id="分页操作"><a href="#分页操作" class="headerlink" title="分页操作"></a>分页操作</h2><h3 id="导入pagehelper包"><a href="#导入pagehelper包" class="headerlink" title="导入pagehelper包"></a>导入pagehelper包</h3><pre><code class="xml">&lt;!--pagehelper所需依赖--&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;            &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;            &lt;version&gt;4.1.6&lt;/version&gt;        &lt;/dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;com.github.jsqlparser&lt;/groupId&gt;            &lt;artifactId&gt;jsqlparser&lt;/artifactId&gt;            &lt;version&gt;0.9.5&lt;/version&gt;        &lt;/dependency&gt;</code></pre><pre><code class="mysql">pageNum:当前页码pageSize：每页数据条数total：数据总记录数    SELECT COUNT(*) FROM books；startIndex = （pageNum - 1） * pagesize  起始下标pages = total / pageSize；    总页数SELECT * FROM books LIMIT    起始下标，每页显示的数据条数</code></pre><pre><code class="xml">    &lt;!-- 配置pagehelper拦截器 --&gt;    &lt;plugins&gt;        &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;            &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;</code></pre><h1 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h1><h3 id="什么是mvc"><a href="#什么是mvc" class="headerlink" title="什么是mvc"></a>什么是mvc</h3><pre><code>Model 数据模型View 视图Controller 控制器MVC是一种Web应用架构，是一种代码设计思想思想：将所有客户端请求全部交由控制器，由控制器将其分发并将结果响应给客户端</code></pre><h4 id="执行过程"><a href="#执行过程" class="headerlink" title="执行过程"></a>执行过程</h4><p>分为六步：</p><ul><li>DispatcherServlet</li></ul><p>SpringMVC核心控制器：前端控制器，主要作用是用来分发</p><ul><li>HandlerMapping</li></ul><p>映射处理器：根据请求url映射到具体的处理Handler</p><p>Handler就是Controller层的实现类，也称为Action或Controller</p><ul><li>HandlerAdapter</li></ul><p>适配器：用来适配不同的处理器Handler</p><p>处理器有两种实现方式：实现接口、基于注解，所以执行之前需要先适配</p><ul><li>Handler</li></ul><p>处理器：执行处理具体业务，并产生数据模型Model和视图名View</p><p>Handler会将数据模型Model和视图名View封装成ModelAndView对象并返回</p><ul><li>ViewResolver</li></ul><p>视图解析器：根据视图名解析为具体的视图，一般多为jsp页面，然后封装为View对象</p><ul><li>View</li></ul><p>视图：使用具体的视图技术进行渲染，结合Model展示数据</p><p>视图有很多种形式：jsp、freemarker、velocity、excel、pdf等</p><h3 id="springmvc主要功能"><a href="#springmvc主要功能" class="headerlink" title="springmvc主要功能"></a>springmvc主要功能</h3><p>在获取多个参数、文件上传、servelt功能方面都能有很好的方法解决</p><h4 id="springMVC框架的搭建"><a href="#springMVC框架的搭建" class="headerlink" title="springMVC框架的搭建"></a>springMVC框架的搭建</h4><p>第一步：导入springmvc的jar包</p><p>第二步：书写主配置文件：SpringMVC.xml，web.xml</p><pre><code class="xml">SpringMVC.xml的配置&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans-4.2.xsd             http://www.springframework.org/schema/mvc             http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context-4.2.xsd &quot;&gt;                        &lt;!-- 配置包扫描 --&gt;            &lt;context:component-scan base-package=&quot;cn.java.controller&quot;&gt;&lt;/context:component-scan&gt;                        &lt;!-- 加入springMVC特有的注解驱动 --&gt;            &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;            &lt;/beans&gt;</code></pre><pre><code class="xml">web.xml的配置&lt;!-- 配置springMVC的核心控制类：DispatcherServlet --&gt;  &lt;servlet&gt;          &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- 别名 --&gt;          &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- DispatcherServlet的地址 --&gt;          &lt;init-param&gt;              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;              &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;          &lt;/init-param&gt;  &lt;/servlet&gt;  &lt;servlet-mapping&gt;      &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/servlet-mapping&gt;</code></pre><p>第三步：启动tomcat测试</p><pre><code class="Java">//java代码配置import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import cn.java.entity.User;@Controller//如果一个普通类被@Controller注解，则普通类变成servletpublic class FrontServlet &#123;        @RequestMapping(value = &quot;/login.html&quot;) //为当前方法配置一个对外访问的虚拟路径    public void Login(User user) &#123;        System.out.println(&quot;登陆成功&quot;);        System.out.println(user);    &#125;        @RequestMapping(value = &#123;&quot;/register.html&quot;,&quot;/zhucechenggong.html&quot;&#125;)    public void Register() &#123;        System.out.println(&quot;注册成功&quot;);    &#125;    &#125;</code></pre><h2 id="Spring-MVC常见注解"><a href="#Spring-MVC常见注解" class="headerlink" title="Spring MVC常见注解"></a>Spring MVC常见注解</h2><h3 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h3><pre><code class="Java">@Controller//如果一个普通类被@Controller注解，则普通类变成servletpublic class FrontServlet &#123;        @RequestMapping(value = &quot;/login.html&quot;) //为当前方法配置一个对外访问的虚拟路径    public void Login(User user) &#123;        System.out.println(&quot;登陆成功&quot;);        System.out.println(user);    &#125;        @RequestMapping(value = &#123;&quot;/register.html&quot;,&quot;/zhucechenggong.html&quot;&#125;)    public void Register() &#123;        System.out.println(&quot;注册成功&quot;);    &#125;    &#125;</code></pre><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><pre><code class="Java">@RequestMapping(value = &quot;/login.html&quot;) //为当前方法配置一个对外访问的虚拟路径    public void Login(User user) &#123;        System.out.println(&quot;登陆成功&quot;);        System.out.println(user);    &#125;</code></pre><h3 id="Scope-单例，多例"><a href="#Scope-单例，多例" class="headerlink" title="@Scope(单例，多例)"></a>@Scope(单例，多例)</h3><pre><code class="Java">@Scope(&quot;prototype&quot;)public class HomeController &#123;    @RequestMapping(value = &quot;/test01.htm&quot;)    public void test01(User user) &#123;        System.out.println(&quot;test.........&quot;);        System.out.println(user);    &#125;    &#125;</code></pre><h3 id="AutoWired（依赖注入）"><a href="#AutoWired（依赖注入）" class="headerlink" title="@AutoWired（依赖注入）"></a>@AutoWired（依赖注入）</h3><blockquote><p>当使用Spring框架进行Java应用程序开发时，可以使用<code>@Autowired</code>注解来自动装配依赖项。下面是一个简单的代码样例，演示了如何使用<code>@Autowired</code>注解注入依赖项。</p><p>首先，我们有一个名为<code>UserService</code>的服务类，它依赖于名为<code>UserRepository</code>的存储库类。使用<code>@Autowired</code>注解，我们可以自动将<code>UserRepository</code>注入到<code>UserService</code>中。</p><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Service;@Servicepublic class UserService &#123;    private UserRepository userRepository;    @Autowired    public UserService(UserRepository userRepository) &#123;        this.userRepository = userRepository;    &#125;    // 其他方法省略...    public void printUsers() &#123;        // 使用注入的UserRepository对象执行操作        List&lt;User&gt; users = userRepository.getUsers();        for (User user : users) &#123;            System.out.println(user.getName());        &#125;    &#125;&#125;</code></pre><p>接下来，我们有一个名为<code>UserRepository</code>的存储库类，它提供了对用户数据的访问方法。</p><pre><code class="java">import org.springframework.stereotype.Repository;@Repositorypublic class UserRepository &#123;    // 数据访问方法省略...    public List&lt;User&gt; getUsers() &#123;        // 返回用户列表的逻辑...    &#125;&#125;</code></pre><p>在上述代码中，<code>UserRepository</code>类使用<code>@Repository</code>注解进行注释，表示它是一个用于数据访问的存储库类。</p><p>最后，我们可以在应用程序的入口点或其他类中使用<code>UserService</code>，并调用其方法。</p><pre><code class="java">import org.springframework.beans.factory.annotation.Autowired;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class MyApp &#123;    private UserService userService;    @Autowired    public MyApp(UserService userService) &#123;        this.userService = userService;    &#125;    public static void main(String[] args) &#123;        SpringApplication.run(MyApp.class, args);    &#125;    // 其他方法省略...    public void doSomething() &#123;        userService.printUsers();    &#125;&#125;</code></pre><p>在上述代码中，<code>MyApp</code>类使用<code>@Autowired</code>注解将<code>UserService</code>注入进来，并调用其中的方法。</p><p>使用<code>@Autowired</code>注解，Spring框架会在运行时自动查找匹配的依赖项，并将它们注入到相应的类中。这样，我们就可以方便地管理和使用依赖项，提高代码的可维护性和可测试性。</p></blockquote><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><pre><code class="Java">    @RequestMapping(value = &quot;/test02.htm&quot;)    public void test02(@RequestParam(name = &quot;user&quot;,defaultValue = &quot;zhangsan&quot;,required = false) String username,            @RequestParam(name = &quot;pasd&quot;)String password,@RequestParam(name = &quot;age&quot;) Integer age) &#123;        System.out.println(&quot;test02.........&quot;);        System.out.println(username);        System.out.println(password);        System.out.println(age);    &#125;</code></pre><h2 id="SpringMVC重定向与转发"><a href="#SpringMVC重定向与转发" class="headerlink" title="SpringMVC重定向与转发"></a>SpringMVC重定向与转发</h2><pre><code class="Java">传统转发@RequestMapping(value = &quot;/test03&quot;)    public void test03(String user,String pasd,String age,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            request.getRequestDispatcher(&quot;/pages/front/success.jsp&quot;).forward(request,response);        &#125;else &#123;            request.getRequestDispatcher(&quot;/index.jsp&quot;).forward(request,response);        &#125;    &#125;</code></pre><pre><code class="Java">传统重定向    @RequestMapping(value = &quot;/test04&quot;)    public void test04(String user,String pasd,String age,HttpServletRequest request,HttpServletResponse response) throws ServletException, IOException &#123;        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            response.sendRedirect(&quot;/dt48_springMVC2/pages/front/success.jsp&quot; );        &#125;else &#123;            response.sendRedirect(&quot;/dt48_springMVC2/pages/front/fail.jsp&quot;);        &#125;    &#125;    </code></pre><pre><code class="Java">    //springmvc重定向    @RequestMapping(value = &quot;/test05&quot;)    public String test05(String user,String pasd,String age)&#123;        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            return &quot;redirect:/pages/front/success.jsp&quot;;//重定向        &#125;else &#123;            return &quot;forward:/pages/front/fail.jsp&quot;;//转发        &#125;    &#125;</code></pre><h3 id="视图解析器（对重定向无效）"><a href="#视图解析器（对重定向无效）" class="headerlink" title="视图解析器（对重定向无效）"></a>视图解析器（对重定向无效）</h3><pre><code class="xml">&lt;!-- 视图解析器 --&gt;            &lt;bean id = &quot;internalResourceViewResolver&quot; class = &quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;                &lt;!-- 配置前缀 --&gt;                &lt;property name =&quot;prefix&quot; value = &quot;/pages/front/&quot;&gt;&lt;/property&gt;                &lt;!-- 配置后缀 --&gt;                &lt;property name = &quot;suffix&quot; value = &quot;.jsp&quot; &gt;&lt;/property&gt;            &lt;/bean&gt;</code></pre><pre><code class="Java">    //springmvc重定向    @RequestMapping(value = &quot;/test06&quot;)    public String test06(String user,String pasd,String age)&#123;        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            return &quot;success&quot;;//重定向        &#125;else &#123;            return &quot;fail&quot;;//转发        &#125;    &#125;    </code></pre><h3 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h3><pre><code>在web.xml中  &lt;!-- 配置过滤器 --&gt;  &lt;filter&gt;      &lt;filter-name&gt;encodingFilters&lt;/filter-name&gt;      &lt;filter-class&gt;cn.java.filters.EncodingFilters&lt;/filter-class&gt;  &lt;/filter&gt;    &lt;filter-mapping&gt;      &lt;filter-name&gt;encodingFilters&lt;/filter-name&gt;      &lt;url-pattern&gt;/*&lt;/url-pattern&gt;  &lt;/filter-mapping&gt;  在java中  package cn.java.filters;import java.io.IOException;import javax.servlet.Filter;import javax.servlet.FilterChain;import javax.servlet.ServletException;import javax.servlet.ServletRequest;import javax.servlet.ServletResponse;//过滤器public class EncodingFilters implements Filter&#123;    @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain)            throws IOException, ServletException &#123;                request.setCharacterEncoding(&quot;utf-8&quot;);        response.setCharacterEncoding(&quot;utf-8&quot;);        response.setContentType(&quot;text/html;charset=utf-8&quot;);                filterChain.doFilter(request, response);            &#125;&#125;</code></pre><h3 id="spring-mvc带数据给jsp（共三种方法）"><a href="#spring-mvc带数据给jsp（共三种方法）" class="headerlink" title="spring mvc带数据给jsp（共三种方法）"></a>spring mvc带数据给jsp（共三种方法）</h3><pre><code class="Java">    //通过request域来保存数据    @RequestMapping(&quot;test07&quot;)    public String test07(String user,String pasd,HttpServletRequest request) &#123;        request.setAttribute(&quot;user&quot;, user);        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            return &quot;success&quot;;//重定向        &#125;else &#123;            return &quot;fail&quot;;//转发        &#125;    &#125;        //通过Model封装数据    @RequestMapping(&quot;test08&quot;)    public String test08(String user,String pasd,Model model) &#123;        model.addAttribute(&quot;username&quot;,user);        if(&quot;admin&quot;.equals(user)&amp;&amp;&quot;123&quot;.equals(pasd)) &#123;            return &quot;success&quot;;//重定向        &#125;else &#123;            return &quot;fail&quot;;//转发        &#125;    &#125;        //通过Map集合封装数据    @RequestMapping(&quot;test09&quot;)    public String test09(Map&lt;String, Object&gt; map) &#123;        map.put(&quot;aaa&quot;,&quot;张三&quot;);        return &quot;front/success.jsp&quot;;    &#125;    </code></pre><pre><code class="jsp">    &lt;!-- 通过request域来保存数据 --&gt;    通过request域来保存数据：$&#123;requestScope.user&#125;    &lt;!-- 通过Model封装数据 --&gt;    通过Model封装数据:$&#123;requestScope.user&#125;    &lt;!-- 通过Map集合封装数据 --&gt;    通过Map集合封装数据:$&#123;requestScope.user&#125;</code></pre><h3 id="Spring-MVC统一异常处理"><a href="#Spring-MVC统一异常处理" class="headerlink" title="Spring MVC统一异常处理"></a>Spring MVC统一异常处理</h3><pre><code class="Java">    //统一异常处理方式    @ExceptionHandler(Exception.class)//异常处理注解出现Exception.class错误就去找他    public void excetHand() &#123;        System.out.println(&quot;出错了&quot;);    </code></pre><pre><code class="Java">package cn.java.controller.exception;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;@ControllerAdvice//异常抛出类public class GlobalExceptionHander &#123;        //统一异常处理方式    @ExceptionHandler(Exception.class)//异常处理注解出现Exception.class错误就去找他    public String excetHand(Exception ex) &#123;        System.out.println(&quot;出错了&quot;);        return &quot;fail&quot;;    &#125;        //异常处理注解    @ExceptionHandler(ArithmeticException.class)    public void exceptHand2(Exception ex) &#123;        System.out.println(&quot;哈哈，出错了&quot;);    &#125;&#125;</code></pre><h3 id="SpringMVC之json"><a href="#SpringMVC之json" class="headerlink" title="SpringMVC之json"></a>SpringMVC之json</h3><ol><li><p>将实体类转化为json</p><pre><code class="Java">    @RequestMapping(&quot;beaToJson&quot;)    @ResponseBody    public User beanToJson() &#123;        User user = new User();        user.setUsername(&quot;李四&quot;);        user.setAge(20);        user.setPassword(&quot;123&quot;);        return user;    &#125;</code></pre></li><li><p>将Map集合转化为json</p><pre><code class="Java">    @RequestMapping(&quot;mapToJson&quot;)    @ResponseBody    public Map&lt;String, Object&gt;mapToJson()&#123;        Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();        map.put(&quot;java&quot;, 80f);        map.put(&quot;StringMvc&quot;, 100f);        return map;    &#125;</code></pre></li><li><p>将List集合转化为json</p><pre><code class="Java">    @RequestMapping(&quot;listToJson&quot;)    @ResponseBody    public List&lt;Map&lt;String, Object&gt;&gt; listToJson()&#123;        Map&lt;String, Object&gt; map1 = new HashMap&lt;String, Object&gt;();        map1.put(&quot;java&quot;, 80f);        map1.put(&quot;StringMvc&quot;, 100f);        Map&lt;String, Object&gt; map2 = new HashMap&lt;String, Object&gt;();        map2.put(&quot;java&quot;, 80f);        map2.put(&quot;StringMvc&quot;, 100f);        List&lt;Map&lt;String, Object&gt;&gt; mapList = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();        mapList.add(map1);        return mapList;    &#125;</code></pre></li><li><p>返回boolean类型、int</p><pre><code class="Java">    @RequestMapping(&quot;test1&quot;)    @ResponseBody//可以返回数值    public String test1() &#123;        System.out.println(&quot;Test1Controller.......&quot;);        return &quot;hello springmvc&quot;;    &#125;</code></pre><h3 id="springMVC文件上传"><a href="#springMVC文件上传" class="headerlink" title="springMVC文件上传"></a>springMVC文件上传</h3><blockquote><p>导入文件上传的jar包</p><p>在springmvc.xml配置文件上传相关配置</p><pre><code class="xml">&lt;!--                  配置文件上传配置                    注意：id必须为multipartResolver            --&gt;            &lt;bean id = &quot;multipartResolver&quot; class = &quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;                &lt;!-- 配置文件上传的编码 --&gt;                &lt;property name = &quot;defaultEncoding&quot; value = &quot;utf-8&quot; &gt;&lt;/property&gt;                &lt;!-- 配置文件上传大小 --&gt;                &lt;property name = &quot;maxUploadSize&quot; value = &quot;1,048,576&quot; &gt;&lt;/property&gt;            &lt;/bean&gt;</code></pre><p>如果表单中有file控件，则必须指定enctype &#x3D; “multipart&#x2F;form-data”</p></blockquote></li><li><p>单文件上传</p><pre><code class="Java">//单文件上传    @RequestMapping(&quot;singleFileUpload&quot;)    public void singleFileUpload(@RequestParam(name = &quot;bigHeadImage&quot;) MultipartFile file) throws IllegalStateException, IOException &#123;        //1. getOriginalFilename获取上传文件的文件名        String originalFilename = file.getOriginalFilename();        //getName()获取表单控件的控件名&lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;        String name = file.getName();        //将上传文件保存到指定目录下        File filePathFile = new File(&quot;C:\\ALL\\project\\GithubProject\\SpringFamilyBase\\dt48_springMVC2\\src\\main\\webapp\\upload\\&quot; + originalFilename );        file.transferTo(filePathFile);    &#125;</code></pre><pre><code class="html">&lt;body&gt;    &lt;h1&gt;文件上传成功&lt;/h1&gt;    &lt;form action = &quot;&lt;%=basePath %&gt;/singleFileUpload.shtml&quot; method = &quot;post&quot; enctype = &quot;multipart/form-data&quot;&gt;        &lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;        &lt;p&gt;大头照&lt;input type = &quot;submit&quot; name = &quot;上传&quot;&gt;&lt;/p&gt;    &lt;/form&gt;&lt;/body&gt;</code></pre><pre><code class="Java">    //单文件上传    @RequestMapping(&quot;singleFileUpload&quot;)    public void singleFileUpload(@RequestParam(name = &quot;bigHeadImage&quot;) MultipartFile file,HttpServletRequest request) throws IllegalStateException, IOException &#123;        //1. getOriginalFilename获取上传文件的文件名        String originalFilename = file.getOriginalFilename();        //getName()获取表单控件的控件名&lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;        String name = file.getName();        String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        //将上传文件保存到指定目录下        File filePathFile = new File(&quot;&quot;+path+&quot;\\&quot; + originalFilename );        file.transferTo(filePathFile);    &#125;        @RequestMapping(value = &quot;getUploadPath&quot;)    public void getUploadPath(HttpServletRequest request) &#123;        ServletContext sc =  request.getServletContext();        String path = sc.getRealPath(&quot;/upload&quot;);        System.out.println(path);    &#125;</code></pre><h4 id="标准的单文件代码上传代码"><a href="#标准的单文件代码上传代码" class="headerlink" title="标准的单文件代码上传代码"></a>标准的单文件代码上传代码</h4><pre><code class="Java">    //单文件上传    @RequestMapping(&quot;singleFileUpload&quot;)    public void singleFileUpload(@RequestParam(name = &quot;bigHeadImage&quot;) MultipartFile file,HttpServletRequest request) throws IllegalStateException, IOException &#123;        //1. getOriginalFilename获取上传文件的文件名        String originalFilename = file.getOriginalFilename();        //getName()获取表单控件的控件名&lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;        String name = file.getName();        //UUID可以生成不重复序列号        String uuidString =  UUID.randomUUID().toString();         String path = request.getServletContext().getRealPath(&quot;/upload&quot;);        //将上传文件保存到指定目录下        File filePathFile = new File(&quot;&quot;+path+&quot;\\&quot; + uuidString + originalFilename );        file.transferTo(filePathFile);    &#125;</code></pre></li><li><p>多文件上传</p><pre><code class="Java">    //多文件上传    @RequestMapping(&quot;mutipleFileUpload&quot;)    public void mutipleFileUpload(MultipartRequest files,HttpServletRequest request) throws IllegalStateException, IOException &#123;        Map&lt;String, MultipartFile&gt; filemap = files.getFileMap();        Set&lt;String&gt; keySet =  filemap.keySet();        for (String key : keySet) &#123;            MultipartFile file = filemap.get(key);            String originalFilename = file.getOriginalFilename();            //getName()获取表单控件的控件名&lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;            String name = file.getName();            //UUID可以生成不重复序列号            String uuidString =  UUID.randomUUID().toString();             String path = request.getServletContext().getRealPath(&quot;/upload&quot;);            //将上传文件保存到指定目录下            File filePathFile = new File(&quot;&quot;+path+&quot;\\&quot; + uuidString + originalFilename );            file.transferTo(filePathFile);        &#125;    &#125;</code></pre></li></ol><h4 id="将其封装到一个类中"><a href="#将其封装到一个类中" class="headerlink" title="将其封装到一个类中"></a>将其封装到一个类中</h4><pre><code class="java">package cn.java.util;import java.io.File;import java.io.IOException;import java.util.HashMap;import java.util.Map;import java.util.Set;import java.util.UUID;import javax.servlet.http.HttpServletRequest;import org.springframework.web.multipart.MultipartFile;import org.springframework.web.multipart.MultipartRequest;//此工具类可以同时上传多个文件public class FileUpload &#123;        /**     * 多文件上传     * @param files     * @param request     */    public static Map&lt;String, Object&gt; uploadFiles(MultipartRequest files,HttpServletRequest request) &#123;        Map&lt;String, Object&gt; filePathMap = new HashMap&lt;String,Object&gt;();        try &#123;            Map&lt;String, MultipartFile&gt; filemap = files.getFileMap();            Set&lt;String&gt; keySet =  filemap.keySet();            for (String key : keySet) &#123;                MultipartFile file = filemap.get(key);                String originalFilename = file.getOriginalFilename();                //getName()获取表单控件的控件名&lt;p&gt;大头照&lt;input type = &quot;file&quot; name = &quot;bigHeadImage&quot;&gt;&lt;/p&gt;                String name = file.getName();                //UUID可以生成不重复序列号                String uuidString =  UUID.randomUUID().toString();                 String path = request.getServletContext().getRealPath(&quot;/upload&quot;);                String basePathString = path.split(&quot;webapps&quot;)[0] + &quot;webapps\\upload&quot;;                File fileUploadFile = new File(basePathString);                if(!fileUploadFile.exists()) &#123;                    fileUploadFile.mkdir();                &#125;                String filepathString = basePathString+&quot;\\&quot;+uuidString+originalFilename;                file.transferTo(new File(filepathString));                //String positivaPath = &quot;uploads/&quot; + uuidString  + originalFilename;                //将上传文件保存到指定目录下                //File filePathFile = new File(&quot;&quot;+path+&quot;\\&quot; + uuidString + originalFilename );                //file.transferTo(filePathFile);                //filePathMap.put(uuidString, positivaPath);            &#125;        &#125; catch (Exception e) &#123;            // TODO Auto-generated catch block            e.printStackTrace();        &#125;        return filePathMap;    &#125;    &#125;</code></pre><h3 id="数据校验实例-代价较大"><a href="#数据校验实例-代价较大" class="headerlink" title="数据校验实例(代价较大)"></a>数据校验实例(代价较大)</h3><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;&lt;%    String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort() +request.getContextPath()+&quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;base href=&quot;&lt;%=basePath %&gt;&quot;&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;注册QQ&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;center&gt;        &lt;form action = &quot;&lt;%=basePath %&gt;/register.shtml&quot; method = &quot;post&quot;&gt;            &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;昵称&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;nick&quot; pattern = &quot;[\u4e00-\u9fa5]&#123;4,10&#125;&quot; required=&quot;required&quot; placeholder = &quot;请输入4-10为汉字&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;password&quot; name = &quot;password&quot; patterm =&quot;\w&#123;3,6&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入3-6位数字、字母、下划线&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;手机号&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;phone&quot; patterm =&quot;1[3578]\d&#123;9&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入手机号&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;邮箱&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;email&quot; name = &quot;email&quot;  required = &quot;required&quot; placeholder = &quot;请输入邮箱&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;年龄&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;age&quot; patterm =&quot;[1-9]\d&#123;0,2&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入真实年龄&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan = &quot;2&quot;&gt;&lt;input type = &quot;submit&quot; value = &quot;注册&quot;&gt;&lt;input type = &quot;reset&quot; value = &quot;重置&quot;&gt;&lt;/td&gt;                    &lt;td&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><pre><code class="Java">package cn.java.controller.front;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import cn.java.entity.QQ;@Controllerpublic class ValidateQQController &#123;        @RequestMapping(&quot;register&quot;)    public void register(QQ qqInfo) &#123;        System.out.println(&quot;进入了&quot;);        System.out.println(qqInfo);        String nick = qqInfo.getNick();        boolean flag1 = nick.matches(&quot;[\\u4e00-\\u9fa5]&#123;4,10&#125;&quot;);                String password = qqInfo.getPassword();        boolean flag2 = password.matches(&quot;\\w&#123;3,6&#125;&quot;);                String phone = qqInfo.getPhone();        boolean flag3 = phone.matches(&quot;1\\d&#123;10&#125;&quot;);                String email = qqInfo.getEmail();        boolean flag4 = email.matches(&quot;[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]&#123;2,&#125;&quot;);        Integer age = qqInfo.getAge();        boolean flag5 = false;        if (age&gt;=1&amp;&amp;age&lt;=150) &#123;            flag5 = true;        &#125;                if (flag1 &amp;&amp; flag2 &amp;&amp; flag3 &amp;&amp; flag4 &amp;&amp; flag5) &#123;            System.out.println(&quot;数据正确&quot;);        &#125;else &#123;            System.out.println(&quot;数据错误&quot;);        &#125;            &#125;&#125;</code></pre><pre><code class="Java">package cn.java.entity;public class QQ &#123;        private String nick;        private String password;        private String phone;        private String email;        private Integer age;    public String getNick() &#123;        return nick;    &#125;    public void setNick(String nick) &#123;        this.nick = nick;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;QQ [nick=&quot; + nick + &quot;, passsword=&quot; + password + &quot;, phone=&quot; + phone + &quot;, email=&quot; + email + &quot;, age=&quot;                + age + &quot;]&quot;;    &#125;&#125;</code></pre><p><strong>特此注明名字一定要一样不一样值就传不回来</strong></p><p>SpringMVC中的数据校验</p><ol><li><p>导入jar包</p></li><li><p>编写配置文件springmvc.xml</p><pre><code class="xml">        &lt;!-- 配置hibernate-validator --&gt;        &lt;mvc:annotation-driven validator=&quot;validator&quot;/&gt;        &lt;bean id=&quot;validator&quot; class=&quot;org.springframework.validation.beanvalidation.LocalValidatorFactoryBean&quot;&gt;            &lt;property name=&quot;providerClass&quot; value=&quot;org.hibernate.validator.HibernateValidator&quot; /&gt;        &lt;/bean&gt;</code></pre></li><li><p>编写代码</p><pre><code class="Java">package cn.java.entity;import javax.validation.constraints.Pattern;import org.hibernate.validator.constraints.Email;public class QQ &#123;        @Pattern(regexp = &quot;[\\u4e00-\\u9fa5]&#123;4,10&#125;&quot;,message = &quot;昵称错误&quot;)    private String nick;        @Pattern(regexp = &quot;\\w&#123;3,6&#125;&quot;,message = &quot;密码错误&quot;)    private String password;        @Pattern(regexp = &quot;1\\\\d&#123;10&#125;&quot;,message = &quot;手机号错误&quot;)    private String phone;        @Email(message = &quot;你输入的邮箱格式有误&quot;)    private String email;            private Integer age;    public String getNick() &#123;        return nick;    &#125;    public void setNick(String nick) &#123;        this.nick = nick;    &#125;    public String getPassword() &#123;        return password;    &#125;    public void setPassword(String password) &#123;        this.password = password;    &#125;    public String getPhone() &#123;        return phone;    &#125;    public void setPhone(String phone) &#123;        this.phone = phone;    &#125;    public String getEmail() &#123;        return email;    &#125;    public void setEmail(String email) &#123;        this.email = email;    &#125;    public Integer getAge() &#123;        return age;    &#125;    public void setAge(Integer age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return &quot;QQ [nick=&quot; + nick + &quot;, passsword=&quot; + password + &quot;, phone=&quot; + phone + &quot;, email=&quot; + email + &quot;, age=&quot;                + age + &quot;]&quot;;    &#125;&#125;</code></pre><pre><code class="Java">    @RequestMapping(&quot;register2&quot;)    public void register1(@Valid QQ qqInfo,BindingResult errorResult) &#123;//必须BindingResult挨着实体类        boolean flag = errorResult.hasErrors();        if (flag) &#123;            //数据有误            List&lt;FieldError&gt; errorList = errorResult.getFieldErrors();            for (FieldError fieldError : errorList) &#123;                //获取实体类中的属性名                String fieldName = fieldError.getField();                //当前数据不满足规则时，获取错误提示信息                String errorMessage = fieldError.getDefaultMessage();                System.out.println(fieldName+&quot;=&quot;+errorMessage);             &#125;        &#125;else &#123;            System.out.println(&quot;正确了&quot;);        &#125;    &#125;</code></pre><pre><code class="JSP">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot; pageEncoding=&quot;UTF-8&quot; isELIgnored=&quot;false&quot;%&gt;&lt;%    String basePath = request.getScheme()+&quot;://&quot;+request.getServerName()+&quot;:&quot;+request.getServerPort() +request.getContextPath()+&quot;/&quot;;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;base href=&quot;&lt;%=basePath %&gt;&quot;&gt;    &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;    &lt;title&gt;注册QQ&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;center&gt;        &lt;form action = &quot;&lt;%=basePath %&gt;/register2.shtml&quot; method = &quot;post&quot;&gt;            &lt;table&gt;                &lt;tr&gt;                    &lt;td&gt;昵称&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;nick&quot; pattern = &quot;[\u4e00-\u9fa5]&#123;4,10&#125;&quot; required=&quot;required&quot; placeholder = &quot;请输入4-10为汉字&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;密码&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;password&quot; name = &quot;password&quot; patterm =&quot;\w&#123;3,6&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入3-6位数字、字母、下划线&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;手机号&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;phone&quot; patterm =&quot;1\\d&#123;10&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入手机号&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;邮箱&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;email&quot; name = &quot;email&quot;  required = &quot;required&quot; placeholder = &quot;请输入邮箱&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td&gt;年龄&lt;/td&gt;                    &lt;td&gt;&lt;input type = &quot;text&quot; name = &quot;age&quot; patterm =&quot;[1-9]\d&#123;0,2&#125;&quot; required = &quot;required&quot; placeholder = &quot;请输入真实年龄&quot;&gt;&lt;/td&gt;                &lt;/tr&gt;                &lt;tr&gt;                    &lt;td colspan = &quot;2&quot;&gt;&lt;input type = &quot;submit&quot; value = &quot;注册&quot;&gt;&lt;input type = &quot;reset&quot; value = &quot;重置&quot;&gt;&lt;/td&gt;                    &lt;td&gt;&lt;/td&gt;                &lt;/tr&gt;            &lt;/table&gt;        &lt;/form&gt;    &lt;/center&gt;&lt;/body&gt;&lt;/html&gt;</code></pre></li></ol><blockquote><p>@AssertTrue &#x2F;&#x2F;用于boolean字段，该字段只能为true<br>@AssertFalse&#x2F;&#x2F;该字段的值只能为false<br>@CreditCardNumber&#x2F;&#x2F;对信用卡号进行一个大致的验证<br>@DecimalMax&#x2F;&#x2F;只能小于或等于该值<br>@DecimalMin&#x2F;&#x2F;只能大于或等于该值<br>@Digits(integer&#x3D;2,fraction&#x3D;20)&#x2F;&#x2F;检查是否是一种数字的整数、分数,小数位数的数字。<br>@Email&#x2F;&#x2F;检查是否是一个有效的email地址<br>@Future&#x2F;&#x2F;检查该字段的日期是否是属于将来的日期<br>@Length(min&#x3D;,max&#x3D;)&#x2F;&#x2F;检查所属的字段的长度是否在min和max之间,只能用于字符串<br>@Max&#x2F;&#x2F;该字段的值只能小于或等于该值<br>@Min&#x2F;&#x2F;该字段的值只能大于或等于该值<br>@NotNull&#x2F;&#x2F;不能为null<br>@NotBlank&#x2F;&#x2F;不能为空，检查时会将空格忽略<br>@NotEmpty&#x2F;&#x2F;不能为空，这里的空是指空字符串<br>@Null&#x2F;&#x2F;检查该字段为空<br>@Past&#x2F;&#x2F;检查该字段的日期是在过去<br>@Size(min&#x3D;, max&#x3D;)&#x2F;&#x2F;检查该字段的size是否在min和max之间，可以是字符串、数组、集合、Map等<br>@URL(protocol&#x3D;,host,port)&#x2F;&#x2F;检查是否是一个有效的URL，如果提供了protocol，host等，则该URL还需满足提供的条件<br>@Valid&#x2F;&#x2F;该注解只要用于字段为一个包含其他对象的集合或map或数组的字段，或该字段直接为一个其他对象的引用，<br>        &#x2F;&#x2F;这样在检查当前对象的同时也会检查该字段所引用的对象</p></blockquote><h3 id="将其封装到类中"><a href="#将其封装到类中" class="headerlink" title="将其封装到类中"></a>将其封装到类中</h3><pre><code class="Java">package cn.java.util;import java.util.HashMap;import java.util.List;import java.util.Map;import javax.validation.Valid;import org.springframework.validation.BindingResult;import org.springframework.validation.FieldError;public class Validator &#123;        /**     * 校验实体类中的属性是否正确     * @param qqInfo     * @param errorResult     * @return :如果返回值为null，则代表数据完全正确，如果不为null，则返回一个封装错误信息map集合     */    public static Map&lt;String,Object&gt; fieldValidate(BindingResult errorResult) &#123;        Map&lt;String,Object&gt; errorMap =null;        boolean flag = errorResult.hasErrors();        if (flag) &#123;            errorMap = new HashMap&lt;String,Object&gt;();            //数据有误            List&lt;FieldError&gt; errorList = errorResult.getFieldErrors();            for (FieldError fieldError : errorList) &#123;                //获取实体类中的属性名                String fieldName = fieldError.getField();                //当前数据不满足规则时，获取错误提示信息                String errorMessage = fieldError.getDefaultMessage();                System.out.println(fieldName+&quot;=&quot;+errorMessage);                errorMap.put(errorMessage, errorList);             &#125;        &#125;        return null;    &#125;&#125;</code></pre><h3 id="在controller中的调用"><a href="#在controller中的调用" class="headerlink" title="在controller中的调用"></a>在controller中的调用</h3><pre><code class="Java">@RequestMapping(&quot;register3&quot;)    public String register3(@Valid QQ qqInfo,BindingResult errorResult,Model model) &#123;        Map&lt;String, Object&gt; resultMap = Validator.fieldValidate(errorResult);        if (resultMap == null) &#123;//数据正确            return &quot;register_success&quot;;        &#125;else &#123;//数据错误            model.addAttribute(&quot;errorMessage&quot;,resultMap);            return &quot;register&quot;;        &#125;    &#125;</code></pre><h2 id="springMVC中的定时器"><a href="#springMVC中的定时器" class="headerlink" title="springMVC中的定时器"></a>springMVC中的定时器</h2><ol><li>导入jar包</li><li>编写springMVC.xml配置</li></ol><pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:task=&quot;http://www.springframework.org/schema/task&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans-4.2.xsd             http://www.springframework.org/schema/mvc             http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context-4.2.xsd             http://www.springframework.org/schema/task          http://www.springframework.org/schema/task/spring-task-4.2.xsd&quot;&gt;                       &lt;!-- 定时器配置 --&gt;        &lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot; /&gt;          &lt;task:executor id=&quot;executor&quot; keep-alive=&quot;3600&quot; pool-size=&quot;100-200&quot; queue-capacity=&quot;500&quot; rejection-policy=&quot;CALLER_RUNS&quot; /&gt;         &lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; /&gt;            &lt;/beans&gt;</code></pre><ol><li>书写定时任务（常见写法）</li></ol><pre><code class="Java">package cn.java.tasks;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Component;@Componentpublic class Task1 &#123;        @Scheduled(fixedRate = 1000)    public void task1()&#123;        Date cTime = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String str = sdf.format(cTime);        System.out.println(str);    &#125;&#125;</code></pre><ol start="2"><li>书写定时任务（SpringMVC写法）</li></ol><pre><code class="Java">@Componentpublic class Task1 &#123;    @Scheduled(cron = &quot;0/2 20 10 * * ?&quot;)    public void task1()&#123;        Date cTime = new Date();        SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);        String str = sdf.format(cTime);        System.out.println(str);    &#125;&#125;</code></pre><h3 id="404类报错跳转页面"><a href="#404类报错跳转页面" class="headerlink" title="404类报错跳转页面"></a>404类报错跳转页面</h3><pre><code class="web.xml">  &lt;!-- 配置错误错误处理页面 --&gt;  &lt;error-page&gt;      &lt;!-- 错误处理代码 --&gt;      &lt;error-code&gt;404&lt;/error-code&gt;      &lt;!-- 错误跳转页面 --&gt;      &lt;location&gt;/pages/error/404.jsp&lt;/location&gt;  &lt;/error-page&gt;</code></pre><h4 id="数据存放到webcontent下与WEB-INF下的区别"><a href="#数据存放到webcontent下与WEB-INF下的区别" class="headerlink" title="数据存放到webcontent下与WEB-INF下的区别"></a>数据存放到webcontent下与WEB-INF下的区别</h4><blockquote><p>如果数据资源存放到webcontext下，是可以直接访问的。如果数据存放到WEB-INF下，是不能通过在浏览器中的输入url地址或者从定向访问，只能通过转发来访问</p></blockquote><h4 id="springMVC4-spring4-Mybatis整合步骤"><a href="#springMVC4-spring4-Mybatis整合步骤" class="headerlink" title="springMVC4+spring4+Mybatis整合步骤"></a>springMVC4+spring4+Mybatis整合步骤</h4><blockquote><p><code>applicationContext.xml</code> 和 <code>springmvc.xml</code> 都是 Spring 配置文件，但它们在功能和用途上有一些区别：</p><ol><li><p>applicationContext.xml：</p><ul><li>功能：<code>applicationContext.xml</code> 是 Spring 应用程序的核心配置文件，用于配置应用程序中的核心组件和 Bean 定义。它负责配置应用程序的业务逻辑、数据访问对象、服务层、数据源、事务管理等。</li><li>作用范围：<code>applicationContext.xml</code> 在整个 Spring 应用程序中具有全局作用，涵盖了应用程序的所有组件和模块。</li><li>命名空间：<code>applicationContext.xml</code> 声明了 Spring 核心的命名空间，如 <code>xmlns:beans</code> 和 <code>xmlns:context</code>。</li></ul></li><li><p>springmvc.xml：</p><ul><li>功能：<code>springmvc.xml</code> 是 Spring MVC 框架的配置文件，主要用于配置与 Web 层相关的组件和功能。它负责配置控制器、视图解析器、拦截器、文件上传配置、视图解析器等。</li><li>作用范围：<code>springmvc.xml</code> 仅在 Spring MVC 部分起作用，用于配置 Web 层组件，与控制器和视图相关。</li><li>命名空间：<code>springmvc.xml</code> 声明了 Spring MVC 的命名空间，如 <code>xmlns:mvc</code> 和 <code>xmlns:context</code>。</li></ul></li><li><p>文件位置：虽然 <code>applicationContext.xml</code> 和 <code>springmvc.xml</code> 是两个独立的配置文件，但在一个典型的 Spring MVC 应用中，它们通常都位于同一个配置目录下，例如 <code>/WEB-INF/</code> 或 <code>src/main/resources/</code> 目录。</p></li><li><p>载入关系：在典型的 Spring MVC 应用程序中，通常会在 <code>web.xml</code> 文件中使用 <code>ContextLoaderListener</code> 来加载 <code>applicationContext.xml</code>，而在 <code>DispatcherServlet</code> 的配置中使用 <code>ContextLoader</code> 或 <code>ContextLoaderServlet</code> 来加载 <code>springmvc.xml</code>。</p></li></ol><p>综上所述，<code>applicationContext.xml</code> 主要用于配置应用程序的核心组件和功能，包括业务逻辑、数据访问等，而 <code>springmvc.xml</code> 主要用于配置与 Web 层相关的组件和功能，包括控制器、视图解析器等。这两个配置文件在 Spring MVC 应用程序中协同工作，帮助构建一个完整的 Spring MVC 应用。</p></blockquote><ol><li><p>导入jar包50个（放到环境中的spring的lib下）</p></li><li><p>编写配置文件（模板）</p><pre><code class="springmvc.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:task=&quot;http://www.springframework.org/schema/task&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans-4.2.xsd             http://www.springframework.org/schema/mvc             http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context-4.2.xsd             http://www.springframework.org/schema/task                  http://www.springframework.org/schema/task/spring-task-4.2.xsd&quot;&gt;                   &lt;/beans&gt;</code></pre><pre><code class="application.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;     xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-4.2.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;              &lt;/beans&gt;</code></pre><pre><code class="mybatis.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE configuration        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;configuration&gt;    &lt;!-- 配置数据源 --&gt;    &lt;environments default=&quot;development&quot;&gt;        &lt;environment id=&quot;development&quot;&gt;            &lt;transactionManager type=&quot;JDBC&quot; /&gt;            &lt;dataSource type=&quot;POOLED&quot;&gt;                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot; /&gt;                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mydatabase&quot; /&gt;                &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt;                &lt;property name=&quot;password&quot; value=&quot;magichell&quot; /&gt;            &lt;/dataSource&gt;        &lt;/environment&gt;    &lt;/environments&gt;&lt;/configuration&gt;</code></pre></li><li><p>编写配置文件（初始配置）</p></li></ol><pre><code class="springmvc.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;     xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;    xmlns:task=&quot;http://www.springframework.org/schema/task&quot;    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans             http://www.springframework.org/schema/beans/spring-beans-4.2.xsd             http://www.springframework.org/schema/mvc             http://www.springframework.org/schema/mvc/spring-mvc-4.2.xsd             http://www.springframework.org/schema/context             http://www.springframework.org/schema/context/spring-context-4.2.xsd             http://www.springframework.org/schema/task          http://www.springframework.org/schema/task/spring-task-4.2.xsd&quot;&gt;                       &lt;!-- 配置包扫描 --&gt;        &lt;context:component-scan base-package=&quot;cn.java.controller.*,cn.java.service.impl,cn.java.service&quot;&gt;&lt;/context:component-scan&gt;                &lt;!-- mvc注解驱动 --&gt;        &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;                &lt;!-- 视图解析器 --&gt;        &lt;bean id = &quot;internalResourceViewResolver&quot; class = &quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt;            &lt;!-- 配置前缀 --&gt;            &lt;property name = &quot;prefix&quot; value = &quot;/pages/&quot;&gt;&lt;/property&gt;            &lt;!-- 配置后缀 --&gt;            &lt;property name = &quot;suffix&quot; value = &quot;&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;                &lt;!-- 文件上传 --&gt;        &lt;bean id = &quot;multipartResolver&quot; class = &quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot; &gt;             &lt;!-- 配置默认编码 --&gt;            &lt;property name = &quot;defaultEncoding&quot; value = &quot;utf-8&quot;&gt;&lt;/property&gt;            &lt;!-- 配置文件上传的大小 --&gt;            &lt;property name = &quot;maxUploadSize&quot; value = &quot;1048576&quot;&gt;&lt;/property&gt;        &lt;/bean&gt;                &lt;!-- 数据校验 --&gt;                &lt;!-- 定时器 --&gt;        &lt;task:scheduler id=&quot;scheduler&quot; pool-size=&quot;10&quot; /&gt;          &lt;task:executor id=&quot;executor&quot; keep-alive=&quot;3600&quot; pool-size=&quot;100-200&quot; queue-capacity=&quot;500&quot; rejection-policy=&quot;CALLER_RUNS&quot; /&gt;         &lt;task:annotation-driven executor=&quot;executor&quot; scheduler=&quot;scheduler&quot; /&gt;&lt;/beans&gt;</code></pre><pre><code class="applicationContext.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;    xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot;    xsi:schemaLocation=&quot;       http://www.springframework.org/schema/beans        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd        http://www.springframework.org/schema/context       http://www.springframework.org/schema/context/spring-context-4.2.xsd       http://www.springframework.org/schema/tx       http://www.springframework.org/schema/tx/spring-tx-4.2.xsd&quot;&gt;              &lt;!-- 配置数据源 --&gt;       &lt;bean id = &quot;basicDataSource&quot; class = &quot;org.apache.commons.dbcp.BasicDataSource&quot;&gt;               &lt;property name = &quot;driverClassName&quot; value = &quot;com.mysql.jdbc.Driver&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;url&quot; value = &quot;jdbc:mysql://localhost:3306/dt48&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;username&quot; value = &quot;root&quot;&gt;&lt;/property&gt;               &lt;property name = &quot;password&quot; value = &quot;magichell&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;                     &lt;!-- 配置扫描保存sql语句的局部文件xml文件 --&gt;       &lt;bean id = &quot;sqlSessionFactoryBean&quot; class = &quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;           &lt;!-- 配置数据源 --&gt;           &lt;property name=&quot;dataSource&quot; ref = &quot;basicDataSource&quot;&gt;&lt;/property&gt;           &lt;!-- 指定局部xml文件的位置 --&gt;           &lt;property name=&quot;mapperLocations&quot; value = &quot;classpath:cn/java/mapper/*.xml&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;              &lt;!-- 扫描mapper接口类，并且将接口类与xml文件相关联 --&gt;       &lt;bean id = &quot;mapperScannerConfigurer&quot; class = &quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot; &gt;           &lt;!-- 指定mapper接口存放位置 --&gt;           &lt;property name=&quot;basePackage&quot; value = &quot;cn.java.mapper&quot;&gt;&lt;/property&gt;       &lt;/bean&gt;&lt;/beans&gt;</code></pre><pre><code class="web.xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; id=&quot;WebApp_ID&quot; version=&quot;4.0&quot;&gt;  &lt;display-name&gt;dt48_ssm&lt;/display-name&gt;  &lt;welcome-file-list&gt;    &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;  &lt;/welcome-file-list&gt;    &lt;!-- 配置过滤器代码 --&gt;    &lt;filter&gt;          &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;          &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;          &lt;init-param&gt;              &lt;param-name&gt;encoding&lt;/param-name&gt;              &lt;param-value&gt;utf-8&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/filter&gt;      &lt;filter-mapping&gt;          &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;          &lt;url-pattern&gt;/*&lt;/url-pattern&gt;      &lt;/filter-mapping&gt;          &lt;!-- 读取spring：applicationcontext.xml文件 --&gt;      &lt;context-param&gt;          &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;          &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt;      &lt;/context-param&gt;      &lt;listener&gt;          &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt;      &lt;/listener&gt;    &lt;!-- 配置springmvc的核心类：DispatcherServlet --&gt;       &lt;servlet&gt;          &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!-- 别名 --&gt;          &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- DispatcherServlet的地址 --&gt;          &lt;init-param&gt;              &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- Corrected the param-name to contextConfigLocation --&gt;              &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;          &lt;/init-param&gt;      &lt;/servlet&gt;      &lt;servlet-mapping&gt;          &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt;          &lt;url-pattern&gt;*.shtml&lt;/url-pattern&gt;      &lt;/servlet-mapping&gt;    &lt;!-- 400/500报错页面 --&gt;    &lt;error-page&gt;          &lt;!-- 错误处理代码 --&gt;          &lt;error-code&gt;404&lt;/error-code&gt;          &lt;!-- 错误跳转页面 --&gt;          &lt;location&gt;/index.jsp&lt;/location&gt;      &lt;/error-page&gt;      &lt;error-page&gt;          &lt;!-- 错误处理代码 --&gt;          &lt;error-code&gt;500&lt;/error-code&gt;          &lt;!-- 错误跳转页面 --&gt;          &lt;location&gt;/index.jsp&lt;/location&gt;      &lt;/error-page&gt;&lt;/web-app&gt;</code></pre><h4 id="在springmvc中ExceptionHander的作用"><a href="#在springmvc中ExceptionHander的作用" class="headerlink" title="在springmvc中ExceptionHander的作用"></a>在springmvc中ExceptionHander的作用</h4><blockquote><p>在Spring框架中，ExceptionHandler是一个用于处理全局异常的机制。它的作用是捕获和处理在应用程序中发生的未处理异常，以便提供友好的错误信息或执行适当的操作。</p><p>当应用程序中发生异常时，Spring框架将会根据以下的处理流程来寻找并执行对应的异常处理器方法：</p><ol><li><p>应用程序代码抛出异常：当应用程序代码中的某个方法抛出了异常，该异常会开始向调用堆栈的上层传播，直到到达 Spring MVC 控制器或 Spring Boot 的 Web 控制器。</p></li><li><p>异常未被处理：如果异常在控制器中没有被合适地处理，它将被传递到全局异常处理器。</p></li><li><p>全局异常处理器处理异常：全局异常处理器是一个带有<code>@ExceptionHandler</code>注解的方法，用于处理指定类型的异常。这些方法通常位于一个专门的类中，可以是一个@ControllerAdvice类或一个@RestControllerAdvice类。通过这些注解，Spring会自动将这些方法与异常类型进行关联。</p></li><li><p>返回错误响应或执行其他操作：在全局异常处理器中，你可以根据实际需求来编写处理异常的逻辑，例如返回一个自定义的错误响应、记录异常日志、发送电子邮件通知等。</p></li></ol><p>使用ExceptionHandler的好处在于将异常处理逻辑集中在一个地方，使得代码更加模块化和易于维护。此外，全局异常处理器还可以提供更好的用户体验，因为用户将会看到友好的错误信息而不是看到原始的异常堆栈信息。</p><p>以下是一个简单的使用@ControllerAdvice的示例：</p><pre><code class="java">@ControllerAdvicepublic class GlobalExceptionHandler &#123;    @ExceptionHandler(Exception.class)    public ResponseEntity&lt;ErrorResponse&gt; handleException(Exception ex) &#123;        // 构建自定义的ErrorResponse对象，并返回合适的HTTP状态码        ErrorResponse errorResponse = new ErrorResponse(HttpStatus.INTERNAL_SERVER_ERROR.value(), &quot;Something went wrong&quot;);        return new ResponseEntity&lt;&gt;(errorResponse, HttpStatus.INTERNAL_SERVER_ERROR);    &#125;&#125;</code></pre><p>在上述例子中，如果任何未处理的异常被抛出，它都将被GlobalExceptionHandler中的handleException方法捕获，并返回一个带有错误信息的ErrorResponse对象和500状态码（服务器内部错误）。当然，你可以根据实际需求来定义更多的异常处理器方法来处理不同类型的异常。</p></blockquote><h4 id="在spring中transactional的作用"><a href="#在spring中transactional的作用" class="headerlink" title="在spring中transactional的作用"></a>在spring中transactional的作用</h4><blockquote><p>在Spring框架中，<code>@Transactional</code>是一个用于管理事务的注解。它可以应用在方法级别或类级别，用于声明一个方法或一个类中的所有方法应该在一个事务中运行。事务是一组数据库操作，要么全部成功执行，要么全部回滚（撤销）到初始状态，以确保数据的一致性和完整性。</p><p><code>@Transactional</code>注解的主要用途是简化事务的管理，将事务的配置从代码中分离出来，使得事务管理变得更加容易和灵活。在使用<code>@Transactional</code>注解时，Spring会自动为被注解的方法启动一个数据库事务，并在方法执行完成后根据方法的执行情况决定是否提交事务或回滚事务。</p><p><code>@Transactional</code>注解可以用于以下场景：</p><ol><li><p><strong>管理数据库事务：</strong> 当方法涉及到对数据库的修改操作（如插入、更新、删除）时，使用<code>@Transactional</code>可以确保这些操作在一个事务中进行，要么全部成功提交，要么全部回滚，避免数据不一致的问题。</p></li><li><p><strong>事务的传播行为：</strong> <code>@Transactional</code>注解允许你指定事务的传播行为，即当一个事务方法调用另一个事务方法时，如何处理事务。常用的传播行为包括REQUIRED（如果当前没有事务，就创建一个新的事务；如果当前存在事务，就加入到当前事务中）、REQUIRES_NEW（创建一个新的事务，如果当前存在事务，就挂起当前事务）等。</p></li><li><p><strong>事务的隔离级别：</strong> 你可以使用<code>@Transactional</code>注解设置事务的隔离级别，即多个事务之间相互隔离的程度。常用的隔离级别有READ_COMMITTED（读已提交，避免脏读）、REPEATABLE_READ（可重复读，避免脏读和不可重复读）、SERIALIZABLE（串行化，最高隔离级别）等。</p></li><li><p><strong>异常处理：</strong> <code>@Transactional</code>还允许你指定在遇到哪些异常时回滚事务，这样可以确保在某些特定的异常情况下数据回滚到正确的状态。</p></li></ol><p>下面是一个简单的使用<code>@Transactional</code>注解的示例：</p><pre><code class="java">@Servicepublic class ProductService &#123;    @Autowired    private ProductRepository productRepository;    @Transactional    public void updateProductStock(long productId, int newStock) &#123;        Product product = productRepository.findById(productId);        product.setStock(newStock);        productRepository.save(product);    &#125;&#125;</code></pre><p>在上述例子中，<code>updateProductStock</code>方法被<code>@Transactional</code>注解修饰，表示该方法在一个事务中运行。如果在执行<code>productRepository.save(product)</code>时出现了异常，整个方法的操作会回滚，保证了数据的一致性。</p><p>需要注意的是，<code>@Transactional</code>注解的生效需要依赖于Spring的事务管理配置，通常需要在Spring配置文件中配置事务管理器。同时，该注解只能应用于公共的非静态方法上。</p></blockquote><h2 id="spy-properties"><a href="#spy-properties" class="headerlink" title="spy.properties"></a>spy.properties</h2><pre><code class="properties">#### #%L# P6Spy# %%# Copyright (C) 2013 P6Spy# %%# Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at# #      http://www.apache.org/licenses/LICENSE-2.0# # Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# #L%##################################################################### P6Spy Options File                                            ## See documentation for detailed instructions                   ## http://p6spy.github.io/p6spy/2.0/configandusage.html          #################################################################################################################################### MODULES                                                       ##                                                               ## Module list adapts the modular functionality of P6Spy.## Only modules listed are active.        ## (default is com.p6spy.engine.logging.P6LogFactory and         ## com.p6spy.engine.spy.P6SpyFactory)                            ## Please note that the core module (P6SpyFactory) can&#39;t be# # deactivated. ## Unlike the other properties, activation of the changes on     ## this one requires reload.###################################################################modulelist=com.p6spy.engine.spy.P6SpyFactory,com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory################################################################# CORE (P6SPY) PROPERTIES                                      ################################################################## A comma separated list of JDBC drivers to load and register.# (default is empty)## Note: This is normally only needed when using P6Spy in an# application server environment with a JNDI data source or when# using a JDBC driver that does not implement the JDBC 4.0 API# (specifically automatic registration).driverlist=com.mysql.jdbc.Driver# for flushing per statement# (default is false)autoflush = true# sets the date format using Java&#39;s SimpleDateFormat routine. # In case property is not set, miliseconds since 1.1.1970 (unix time) is used (default is empty)#dateformat=# prints a stack trace for every statement logged#stacktrace=false# if stacktrace=true, specifies the stack trace to print#stacktraceclass=# determines if property file should be reloaded# Please note: reload means forgetting all the previously set# settings (even those set during runtime - via JMX)# and starting with the clean table # (default is false)#reloadproperties=false# determines how often should be reloaded in seconds# (default is 60)#reloadpropertiesinterval=60# specifies the appender to use for logging# Please note: reload means forgetting all the previously set# settings (even those set during runtime - via JMX)# and starting with the clean table # (only the properties read from the configuration file)# (default is com.p6spy.engine.spy.appender.FileLogger)#appender=com.p6spy.engine.spy.appender.Slf4JLoggerappender=com.p6spy.engine.spy.appender.StdoutLogger#appender=com.p6spy.engine.spy.appender.FileLogger# name of logfile to use, note Windows users should make sure to use forward slashes in their pathname (e:/test/spy.log) # (used for com.p6spy.engine.spy.appender.FileLogger only)# (default is spy.log)#logfile = spy.log# append to the p6spy log file. if this is set to false the# log file is truncated every time. (file logger only)# (default is true)#append=true# class to use for formatting log messages (default is: com.p6spy.engine.spy.appender.SingleLineFormat)#logMessageFormat=com.p6spy.engine.spy.appender.SingleLineFormat# format that is used for logging of the date/time/... (has to be compatible with java.text.SimpleDateFormat)# (default is dd-MMM-yy)#databaseDialectDateFormat=dd-MMM-yy# whether to expose options via JMX or not# (default is true)#jmx=true# if exposing options via jmx (see option: jmx), what should be the prefix used?# jmx naming pattern constructed is: com.p6spy(.&lt;jmxPrefix&gt;)?:name=&lt;optionsClassName&gt;# please note, if there is already such a name in use it would be unregistered first (the last registered wins)# (default is none)#jmxPrefix=################################################################## DataSource replacement                                        ##                                                               ## Replace the real DataSource class in your application server  ## configuration with the name com.p6spy.engine.spy.P6DataSource ## (that provides also connection pooling and xa support).       ## then add the JNDI name and class name of the real             ## DataSource here                                               ##                                                               ## Values set in this item cannot be reloaded using the          ## reloadproperties variable. Once it is loaded, it remains      ## in memory until the application is restarted.                 ##                                                               ###################################################################realdatasource=/RealMySqlDS#realdatasourceclass=com.mysql.jdbc.jdbc2.optional.MysqlDataSource################################################################## DataSource properties                                         ##                                                               ## If you are using the DataSource support to intercept calls    ## to a DataSource that requires properties for proper setup,    ## define those properties here. Use name value pairs, separate  ## the name and value with a semicolon, and separate the         ## pairs with commas.                                            ##                                                               ## The example shown here is for mysql                           ##                                                               ###################################################################realdatasourceproperties=port;3306,serverName;myhost,databaseName;jbossdb,foo;bar################################################################## JNDI DataSource lookup                                        ##                                                               ## If you are using the DataSource support outside of an app     ## server, you will probably need to define the JNDI Context     ## environment.                                                  ##                                                               ## If the P6Spy code will be executing inside an app server then ## do not use these properties, and the DataSource lookup will   ## use the naming context defined by the app server.             ##                                                               ## The two standard elements of the naming environment are       ## jndicontextfactory and jndicontextproviderurl. If you need    ## additional elements, use the jndicontextcustom property.      ## You can define multiple properties in jndicontextcustom,      ## in name value pairs. Separate the name and value with a       ## semicolon, and separate the pairs with commas.                ##                                                               ## The example shown here is for a standalone program running on ## a machine that is also running JBoss, so the JDNI context     ## is configured for JBoss (3.0.4).                              ##                                                               ## (by default all these are empty)                              ###################################################################jndicontextfactory=org.jnp.interfaces.NamingContextFactory#jndicontextproviderurl=localhost:1099#jndicontextcustom=java.naming.factory.url.pkgs;org.jboss.nameing:org.jnp.interfaces#jndicontextfactory=com.ibm.websphere.naming.WsnInitialContextFactory#jndicontextproviderurl=iiop://localhost:900################################################################# P6 LOGGING SPECIFIC PROPERTIES                               ################################################################## filter what is logged# please note this is a precondition for usage of: include/exclude/sqlexpression# (default is false)#filter=false# comma separated list of strings to include# please note that special characters escaping (used in java) has to be done for the provided regular expression# (default is empty)#include =# comma separated list of strings to exclude# (default is empty)#exclude =# sql expression to evaluate if using regex# please note that special characters escaping (used in java) has to be done for the provided regular expression# (default is empty)#sqlexpression = #list of categories to exclude: error, info, batch, debug, statement,#commit, rollback and result are valid values# (default is info,debug,result,resultset,batch)#excludecategories=info,debug,result,resultset,batch# Execution threshold applies to the standard logging of P6Spy.       # While the standard logging logs out every statement          # regardless of its execution time, this feature puts a time   # condition on that logging. Only statements that have taken   # longer than the time specified (in milliseconds) will be     # logged. This way it is possible to see only statements that  # have exceeded some high water mark.                          # This time is reloadable.                                     ## executionThreshold=integer time (milliseconds)# (default is 0)#executionThreshold=################################################################# P6 OUTAGE SPECIFIC PROPERTIES                                ################################################################## Outage Detection## This feature detects long-running statements that may be indicative of# a database outage problem. If this feature is turned on, it will log any# statement that surpasses the configurable time boundary during its execution.# When this feature is enabled, no other statements are logged except the long# running statements. The interval property is the boundary time set in seconds.# For example, if this is set to 2, then any statement requiring at least 2# seconds will be logged. Note that the same statement will continue to be logged# for as long as it executes. So if the interval is set to 2, and the query takes# 11 seconds, it will be logged 5 times (at the 2, 4, 6, 8, 10 second intervals).## outagedetection=true|false# outagedetectioninterval=integer time (seconds)## (default is false)#outagedetection=false# (default is 60)#outagedetectioninterval=30</code></pre><h2 id="database-properties"><a href="#database-properties" class="headerlink" title="database.properties"></a>database.properties</h2><pre><code class="properties">#Mysqldriver=com.mysql.jdbc.Driverurl=jdbc:mysql://localhost:3306/dt48username=rootpassword=magichell##p6spy#driver=com.p6spy.engine.spy.P6SpyDriver#url=jdbc:p6spy:mysql://localhost:3306/dt48#username=root#password=magichell</code></pre><h3 id="springmvc之拦截器"><a href="#springmvc之拦截器" class="headerlink" title="springmvc之拦截器"></a>springmvc之拦截器</h3><p>在springmvc.xml中配置</p><pre><code class="xml">        &lt;!-- 配置拦截器 --&gt;        &lt;mvc:interceptors&gt;            &lt;mvc:interceptor&gt;                &lt;mvc:mapping path=&quot;/**&quot;/&gt;                &lt;bean id = &quot;oneInterceptor&quot; class = &quot;cn.java.interceptors.OneInterceptor&quot;&gt;&lt;/bean&gt;            &lt;/mvc:interceptor&gt;        &lt;/mvc:interceptors&gt;</code></pre><pre><code class="Java">//拦截器代码package cn.java.interceptors;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;import org.springframework.web.servlet.HandlerInterceptor;import org.springframework.web.servlet.ModelAndView;public class OneInterceptor implements HandlerInterceptor&#123;    @Override    public void afterCompletion(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, Exception arg3)            throws Exception &#123;        // TODO Auto-generated method stub            &#125;    @Override    public void postHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2, ModelAndView arg3)            throws Exception &#123;        // TODO Auto-generated method stub            &#125;    @Override    public boolean preHandle(HttpServletRequest arg0, HttpServletResponse arg1, Object arg2) throws Exception &#123;        // TODO Auto-generated method stub        System.out.println(&quot;OneInterceptor&quot;);        return false;    &#125;&#125;</code></pre><h3 id="JSON请求与响应"><a href="#JSON请求与响应" class="headerlink" title="JSON请求与响应"></a>JSON请求与响应</h3><pre><code class="jsp">&lt;script type=&quot;text/javascript&quot;&gt;        $.fn.serializeObject = function()            &#123;               var o = &#123;&#125;;               var a = this.serializeArray();               $.each(a, function() &#123;                   if (o[this.name]) &#123;                       if (!o[this.name].push) &#123;                           o[this.name] = [o[this.name]];                       &#125;                       o[this.name].push(this.value || &#39;&#39;);                   &#125; else &#123;                       o[this.name] = this.value || &#39;&#39;;                   &#125;               &#125;);               return o;            &#125;;            $(&quot;input[type=submit]&quot;).click(function()&#123;            /* var data = $(&quot;#form1&quot;).serializeArray(); //自动将form表单封装成json              alert(JSON.stringify(data)); */              var jsonuserinfo = $(&#39;#form1&#39;).serializeObject();              var jsonData = JSON.stringify(jsonuserinfo);            //alert(jsonData);            $.ajax(&#123;            url:&#39;&lt;%=basePath %&gt;/formToJson.shtml&#39;,            type:&#39;post&#39;,            dataType:&#39;json&#39;,            contentType: &#39;application/json&#39;,            data:jsonData,            success:function(result)&#123;            alert(result);            &#125;            &#125;);        &#125;);    &lt;/script&gt;</code></pre><pre><code class="Java">    // 获取register.jsp页面传递过来的json数据    @RequestMapping(&quot;getJson&quot;)    // public boolean getJson(@RequestBody Map&lt;String, Object&gt; jsonMap) &#123;    public @ResponseBody boolean getJson(@RequestBody QQ jsonMap) &#123;        System.out.println(&quot;getJson=&quot; + jsonMap);        return true;    &#125;</code></pre><pre><code>&lt;dependencyManagement&gt;        &lt;dependencies&gt;            &lt;dependency&gt;                &lt;groupId&gt;junit&lt;/groupId&gt;                &lt;artifactId&gt;junit&lt;/artifactId&gt;                &lt;version&gt;$&#123;junit.version&#125;&lt;/version&gt;                &lt;scope&gt;test&lt;/scope&gt;            &lt;/dependency&gt;            &lt;!-- JavaEE --&gt;            &lt;dependency&gt;                &lt;groupId&gt;javax.servlet&lt;/groupId&gt;                &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;                &lt;version&gt;3.1.0&lt;/version&gt;                &lt;scope&gt;provided&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt;                &lt;artifactId&gt;jsp-api&lt;/artifactId&gt;                &lt;version&gt;2.2&lt;/version&gt;                &lt;scope&gt;provided&lt;/scope&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;jstl&lt;/groupId&gt;                &lt;artifactId&gt;jstl&lt;/artifactId&gt;                &lt;version&gt;1.2&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- Spring --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-core&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-beans&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-context&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-expression&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-aop&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.springframework&lt;/groupId&gt;                &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;                &lt;version&gt;4.3.16.RELEASE&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- mybatis --&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mybatis&lt;/artifactId&gt;                &lt;version&gt;3.4.5&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;org.mybatis&lt;/groupId&gt;                &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt;                &lt;version&gt;1.3.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt;                &lt;artifactId&gt;pagehelper&lt;/artifactId&gt;                &lt;version&gt;5.1.2&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- Mysql --&gt;            &lt;dependency&gt;                &lt;groupId&gt;mysql&lt;/groupId&gt;                &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;                &lt;version&gt;8.0.32&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;druid&lt;/artifactId&gt;                &lt;version&gt;1.1.6&lt;/version&gt;            &lt;/dependency&gt;            &lt;!-- 工具 --&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;                &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;                &lt;version&gt;1.3.1&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;com.alibaba&lt;/groupId&gt;                &lt;artifactId&gt;fastjson&lt;/artifactId&gt;                &lt;version&gt;1.2.47&lt;/version&gt;            &lt;/dependency&gt;            &lt;dependency&gt;                &lt;groupId&gt;commons-beanutils&lt;/groupId&gt;                &lt;artifactId&gt;commons-beanutils&lt;/artifactId&gt;                &lt;version&gt;1.9.4&lt;/version&gt;            &lt;/dependency&gt;        &lt;/dependencies&gt;    &lt;/dependencyManagement&gt;</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
